import router from '@ohos.router'
import prompt from '@ohos.prompt'

import { fetchWeather } from '../model/WeatherService';
import { ApiService } from '../service/apiservice';
import { Conversation, AiRole } from '../common/types';
import { getUserId } from '../common/constants';
import { avatarCacheManager } from '../utils/AvatarCacheManager';

// ç¼“å­˜æ¥å£å®šä¹‰
interface CacheItem<T> {
  data: T;
  timestamp: number;
  loading: boolean;
  failed: boolean;
  retryCount: number;
}

interface CacheStats {
  total: number;
  success: number;
  failed: number;
  loading: number;
}

// é”™è¯¯ç»“æœæ¥å£
interface ErrorResult {
  status: string;
  reason: string;
}

// æ¶ˆæ¯é¡µé¢ç¼“å­˜ç®¡ç†å™¨
class MessagePageCacheManager {
  private static instance: MessagePageCacheManager;
  
  // ç¼“å­˜å­˜å‚¨
  private conversationCache: Map<number, CacheItem<Conversation[]>> = new Map();
  private aiRoleCache: Map<number, CacheItem<AiRole>> = new Map();
  private recommendationCache: Map<string, CacheItem<AiRole[]>> = new Map();
  private weatherCache: CacheItem<WeatherInfo> | null = null;
  
  // ç¼“å­˜é…ç½®
  private readonly CACHE_EXPIRE_TIME = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  private readonly WEATHER_CACHE_EXPIRE_TIME = 10 * 60 * 1000; // 10åˆ†é’Ÿ
  private readonly MAX_CACHE_SIZE = 100;
  private readonly MAX_RETRY_COUNT = 3;
  
  // åŠ è½½é˜Ÿåˆ—
  private loadingQueue: Set<string> = new Set();
  
  // å•ä¾‹æ¨¡å¼
  public static getInstance(): MessagePageCacheManager {
    if (!MessagePageCacheManager.instance) {
      MessagePageCacheManager.instance = new MessagePageCacheManager();
    }
    return MessagePageCacheManager.instance;
  }
  
  /**
   * è·å–å¯¹è¯åˆ—è¡¨ï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  public async getConversations(userId: number): Promise<Conversation[]> {
    const cacheKey = `conversations_${userId}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.conversationCache.get(userId);
    if (cached && !this.isExpired(cached) && !cached.failed) {
      console.log('ğŸ¯ å¯¹è¯åˆ—è¡¨ç¼“å­˜å‘½ä¸­:', userId);
      return cached.data;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    if (this.loadingQueue.has(cacheKey)) {
      console.log('â³ å¯¹è¯åˆ—è¡¨æ­£åœ¨åŠ è½½ä¸­:', userId);
      // ç­‰å¾…åŠ è½½å®Œæˆ
      return this.waitForLoading(cacheKey, () => this.conversationCache.get(userId)?.data || []);
    }
    
    // å¼€å§‹åŠ è½½
    return this.loadConversations(userId, cacheKey);
  }
  
  /**
   * è·å–AIè§’è‰²ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  public async getAiRole(roleId: number): Promise<AiRole | null> {
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.aiRoleCache.get(roleId);
    if (cached && !this.isExpired(cached) && !cached.failed) {
      console.log('ğŸ¯ AIè§’è‰²ç¼“å­˜å‘½ä¸­:', roleId);
      return cached.data;
    }
    
    // å¼€å§‹åŠ è½½
    return this.loadAiRole(roleId);
  }
  
  /**
   * æ‰¹é‡è·å–AIè§’è‰²ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜å’Œé¢„åŠ è½½ï¼‰
   */
  public async getAiRolesBatch(roleIds: number[]): Promise<Map<number, AiRole>> {
    const result = new Map<number, AiRole>();
    const toLoad: number[] = [];
    
    // æ£€æŸ¥ç¼“å­˜
    for (const roleId of roleIds) {
      const cached = this.aiRoleCache.get(roleId);
      if (cached && !this.isExpired(cached) && !cached.failed) {
        result.set(roleId, cached.data);
      } else {
        toLoad.push(roleId);
      }
    }
    
    // æ‰¹é‡åŠ è½½æœªç¼“å­˜çš„è§’è‰²
    if (toLoad.length > 0) {
      console.log('ğŸ“¥ æ‰¹é‡åŠ è½½AIè§’è‰²:', toLoad.length);
      const loadedRoles = await this.loadAiRolesBatch(toLoad);
      for (const entry of loadedRoles.entries()) {
        const roleId = entry[0];
        const role = entry[1];
        result.set(roleId, role);
      }
    }
    
    return result;
  }
  
  /**
   * è·å–æ··åˆæ¨èï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  public async getHybridRecommendations(userId: number, limit: number = 10): Promise<AiRole[]> {
    const cacheKey = `recommendations_${userId}_${limit}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.recommendationCache.get(cacheKey);
    if (cached && !this.isExpired(cached) && !cached.failed) {
      console.log('ğŸ¯ æ¨èç»“æœç¼“å­˜å‘½ä¸­:', cacheKey);
      return cached.data;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    if (this.loadingQueue.has(cacheKey)) {
      console.log('â³ æ¨èç»“æœæ­£åœ¨åŠ è½½ä¸­:', cacheKey);
      return this.waitForLoading(cacheKey, () => this.recommendationCache.get(cacheKey)?.data || []);
    }
    
    // å¼€å§‹åŠ è½½
    return this.loadRecommendations(userId, limit, cacheKey);
  }
  
  /**
   * è·å–å¤©æ°”ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  public async getWeatherInfo(): Promise<WeatherInfo> {
    // æ£€æŸ¥ç¼“å­˜
    if (this.weatherCache && !this.isExpired(this.weatherCache) && !this.weatherCache.failed) {
      console.log('ğŸ¯ å¤©æ°”ä¿¡æ¯ç¼“å­˜å‘½ä¸­');
      return this.weatherCache.data;
    }
    
    // å¼€å§‹åŠ è½½
    return this.loadWeatherInfo();
  }
  
  /**
   * é¢„åŠ è½½å¤´åƒ
   */
  public async preloadAvatars(aiRoles: AiRole[]): Promise<void> {
    try {
      console.log('ğŸš€ é¢„åŠ è½½å¤´åƒ:', aiRoles.length);
      await avatarCacheManager.preloadAvatars(aiRoles);
    } catch (error) {
      console.error('âŒ é¢„åŠ è½½å¤´åƒå¤±è´¥:', error);
    }
  }
  
  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  public cleanExpiredCache(): void {
    const now = Date.now();
    let cleanedCount = 0;
    
    // æ¸…ç†å¯¹è¯ç¼“å­˜
    for (const entry of this.conversationCache.entries()) {
      const key = entry[0];
      const item = entry[1];
      if (this.isExpired(item)) {
        this.conversationCache.delete(key);
        cleanedCount++;
      }
    }
    
    // æ¸…ç†AIè§’è‰²ç¼“å­˜
    for (const entry of this.aiRoleCache.entries()) {
      const key = entry[0];
      const item = entry[1];
      if (this.isExpired(item)) {
        this.aiRoleCache.delete(key);
        cleanedCount++;
      }
    }
    
    // æ¸…ç†æ¨èç¼“å­˜
    for (const entry of this.recommendationCache.entries()) {
      const key = entry[0];
      const item = entry[1];
      if (this.isExpired(item)) {
        this.recommendationCache.delete(key);
        cleanedCount++;
      }
    }
    
    // æ¸…ç†å¤©æ°”ç¼“å­˜
    if (this.weatherCache && this.isExpired(this.weatherCache)) {
      this.weatherCache = null;
      cleanedCount++;
    }
    
    if (cleanedCount > 0) {
      console.log(`ğŸ§¹ æ¸…ç†äº† ${cleanedCount} ä¸ªè¿‡æœŸç¼“å­˜`);
    }
  }
  
  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡
   */
  public getCacheStats(): CacheStats {
    let total = 0, success = 0, failed = 0, loading = 0;
    
    // ç»Ÿè®¡å¯¹è¯ç¼“å­˜
    for (const item of this.conversationCache.values()) {
      total++;
      if (item.loading) loading++;
      else if (item.failed) failed++;
      else success++;
    }
    
    // ç»Ÿè®¡AIè§’è‰²ç¼“å­˜
    for (const item of this.aiRoleCache.values()) {
      total++;
      if (item.loading) loading++;
      else if (item.failed) failed++;
      else success++;
    }
    
    // ç»Ÿè®¡æ¨èç¼“å­˜
    for (const item of this.recommendationCache.values()) {
      total++;
      if (item.loading) loading++;
      else if (item.failed) failed++;
      else success++;
    }
    
    // ç»Ÿè®¡å¤©æ°”ç¼“å­˜
    if (this.weatherCache) {
      total++;
      if (this.weatherCache.loading) loading++;
      else if (this.weatherCache.failed) failed++;
      else success++;
    }
    
    return { total, success, failed, loading };
  }
  
  /**
   * æ¸…é™¤ç”¨æˆ·ç›¸å…³ç¼“å­˜
   */
  public clearUserCache(userId: number): void {
    // æ¸…é™¤å¯¹è¯ç¼“å­˜
    this.conversationCache.delete(userId);
    
    // æ¸…é™¤æ¨èç¼“å­˜
    const keysToRemove: string[] = [];
    for (const key of this.recommendationCache.keys()) {
      if (key.includes(`_${userId}_`)) {
        keysToRemove.push(key);
      }
    }
    for (const key of keysToRemove) {
      this.recommendationCache.delete(key);
    }
    
    console.log(`ğŸ—‘ï¸ æ¸…é™¤ç”¨æˆ· ${userId} ç›¸å…³ç¼“å­˜`);
  }
  
  // ==================== ç§æœ‰æ–¹æ³• ====================
  
  private async loadConversations(userId: number, cacheKey: string): Promise<Conversation[]> {
    this.loadingQueue.add(cacheKey);
    
    try {
      console.log('ğŸ“¥ å¼€å§‹åŠ è½½å¯¹è¯åˆ—è¡¨:', userId);
      
      // åˆ›å»ºç¼“å­˜é¡¹
      const cacheItem: CacheItem<Conversation[]> = {
        data: [],
        timestamp: Date.now(),
        loading: true,
        failed: false,
        retryCount: 0
      };
      
      this.conversationCache.set(userId, cacheItem);
      
      // è°ƒç”¨API
      const conversations = await ApiService.getConversationsByUserId(userId);
      
      // æ›´æ–°ç¼“å­˜
      cacheItem.data = conversations;
      cacheItem.loading = false;
      cacheItem.failed = false;
      
      console.log('âœ… å¯¹è¯åˆ—è¡¨åŠ è½½æˆåŠŸ:', conversations.length);
      return conversations;
      
    } catch (error) {
      console.error('âŒ å¯¹è¯åˆ—è¡¨åŠ è½½å¤±è´¥:', error);
      
      // æ›´æ–°å¤±è´¥çŠ¶æ€
      const cacheItem = this.conversationCache.get(userId);
      if (cacheItem) {
        cacheItem.loading = false;
        cacheItem.failed = true;
        cacheItem.retryCount++;
      }
      
      return [];
    } finally {
      this.loadingQueue.delete(cacheKey);
    }
  }
  
  private async loadAiRole(roleId: number): Promise<AiRole | null> {
    try {
      console.log('ğŸ“¥ å¼€å§‹åŠ è½½AIè§’è‰²:', roleId);
      
      // åˆ›å»ºç¼“å­˜é¡¹
      const cacheItem: CacheItem<AiRole> = {
        data: {} as AiRole,
        timestamp: Date.now(),
        loading: true,
        failed: false,
        retryCount: 0
      };
      
      this.aiRoleCache.set(roleId, cacheItem);
      
      // è°ƒç”¨API
      const aiRole = await ApiService.getAiRoleById(roleId);
      
      // æ›´æ–°ç¼“å­˜
      cacheItem.data = aiRole;
      cacheItem.loading = false;
      cacheItem.failed = false;
      
      console.log('âœ… AIè§’è‰²åŠ è½½æˆåŠŸ:', roleId);
      return aiRole;
      
    } catch (error) {
      console.error('âŒ AIè§’è‰²åŠ è½½å¤±è´¥:', roleId, error);
      
      // æ›´æ–°å¤±è´¥çŠ¶æ€
      const cacheItem = this.aiRoleCache.get(roleId);
      if (cacheItem) {
        cacheItem.loading = false;
        cacheItem.failed = true;
        cacheItem.retryCount++;
      }
      
      return null;
    }
  }
  
  private async loadAiRolesBatch(roleIds: number[]): Promise<Map<number, AiRole>> {
    const result = new Map<number, AiRole>();
    
    // åˆ†æ‰¹åŠ è½½ï¼Œé¿å…åŒæ—¶è¯·æ±‚è¿‡å¤š
    const batchSize = 5;
    for (let i = 0; i < roleIds.length; i += batchSize) {
      const batch = roleIds.slice(i, i + batchSize);
      const promises: Promise<void>[] = [];
      
      for (const roleId of batch) {
        promises.push(
          this.loadAiRole(roleId).then(role => {
            if (role) {
              result.set(roleId, role);
            }
          })
        );
      }
      
      // ç­‰å¾…æ‰€æœ‰promiseå®Œæˆï¼Œå¿½ç•¥é”™è¯¯
      for (const promise of promises) {
        try {
          await promise;
        } catch (error) {
          // å¿½ç•¥å•ä¸ªè§’è‰²åŠ è½½å¤±è´¥
        }
      }
      
      // æ‰¹æ¬¡é—´å»¶è¿Ÿ
      if (i + batchSize < roleIds.length) {
        await new Promise<void>(resolve => setTimeout(resolve, 100));
      }
    }
    
    return result;
  }
  
  private async loadRecommendations(userId: number, limit: number, cacheKey: string): Promise<AiRole[]> {
    this.loadingQueue.add(cacheKey);
    
    try {
      console.log('ğŸ“¥ å¼€å§‹åŠ è½½æ¨èç»“æœ:', cacheKey);
      
      // åˆ›å»ºç¼“å­˜é¡¹
      const cacheItem: CacheItem<AiRole[]> = {
        data: [],
        timestamp: Date.now(),
        loading: true,
        failed: false,
        retryCount: 0
      };
      
      this.recommendationCache.set(cacheKey, cacheItem);
      
      // è°ƒç”¨API
      const recommendations = await ApiService.getHybridRecommendations(userId, limit);
      
      // æ›´æ–°ç¼“å­˜
      cacheItem.data = recommendations;
      cacheItem.loading = false;
      cacheItem.failed = false;
      
      console.log('âœ… æ¨èç»“æœåŠ è½½æˆåŠŸ:', recommendations.length);
      return recommendations;
      
    } catch (error) {
      console.error('âŒ æ¨èç»“æœåŠ è½½å¤±è´¥:', error);
      
      // æ›´æ–°å¤±è´¥çŠ¶æ€
      const cacheItem = this.recommendationCache.get(cacheKey);
      if (cacheItem) {
        cacheItem.loading = false;
        cacheItem.failed = true;
        cacheItem.retryCount++;
      }
      
      return [];
    } finally {
      this.loadingQueue.delete(cacheKey);
    }
  }
  
  private async loadWeatherInfo(): Promise<WeatherInfo> {
    try {
      console.log('ğŸ“¥ å¼€å§‹åŠ è½½å¤©æ°”ä¿¡æ¯');
      
      // åˆ›å»ºç¼“å­˜é¡¹
      const cacheItem: CacheItem<WeatherInfo> = {
        data: new WeatherInfo(),
        timestamp: Date.now(),
        loading: true,
        failed: false,
        retryCount: 0
      };
      
      this.weatherCache = cacheItem;
      
      // è°ƒç”¨API
      const data = await fetchWeather('101200101'); // æ­¦æ±‰
      
      if (data && data.status === 200 && data.data && data.cityInfo) {
        cacheItem.data.city = data.cityInfo.city;
        cacheItem.data.temperature = data.data.wendu + 'Â°';
        cacheItem.data.desc = data.data.forecast && data.data.forecast.length > 0 ? data.data.forecast[0].type : '';
        cacheItem.data.icon = this.iconMap(cacheItem.data.desc);
      } else {
        cacheItem.data.city = 'è·å–å¤±è´¥';
        cacheItem.data.temperature = '--Â°';
        cacheItem.data.desc = 'å¤©æ°”è·å–å¤±è´¥';
        cacheItem.data.icon = 'âŒ';
      }
      
      cacheItem.loading = false;
      cacheItem.failed = false;
      
      console.log('âœ… å¤©æ°”ä¿¡æ¯åŠ è½½æˆåŠŸ');
      return cacheItem.data;
      
    } catch (error) {
      console.error('âŒ å¤©æ°”ä¿¡æ¯åŠ è½½å¤±è´¥:', error);
      
      if (this.weatherCache) {
        this.weatherCache.loading = false;
        this.weatherCache.failed = true;
        this.weatherCache.retryCount++;
      }
      
      return new WeatherInfo();
    }
  }
  
  private iconMap(desc: string): string {
    switch (desc) {
      case 'æ™´': return 'â˜€ï¸';
      case 'å¤šäº‘': return 'ğŸŒ¤ï¸';
      case 'é˜´': return 'â˜ï¸';
      case 'å°é›¨': return 'ğŸŒ§ï¸';
      case 'ä¸­é›¨': return 'ğŸŒ§ï¸';
      case 'å¤§é›¨': return 'â›ˆï¸';
      case 'é›·é˜µé›¨': return 'â›ˆï¸';
      case 'é›ª': return 'â„ï¸';
      case 'é›¾': return 'ğŸŒ«ï¸';
      default: return 'â“';
    }
  }
  
  private isExpired(cacheItem: CacheItem<Conversation[] | AiRole | AiRole[] | WeatherInfo>): boolean {
    const expireTime = cacheItem.data instanceof WeatherInfo ? this.WEATHER_CACHE_EXPIRE_TIME : this.CACHE_EXPIRE_TIME;
    return Date.now() - cacheItem.timestamp > expireTime;
  }
  
  private async waitForLoading<T>(cacheKey: string, getData: () => T): Promise<T> {
    // ç­‰å¾…åŠ è½½å®Œæˆ
    let attempts = 0;
    const maxAttempts = 50; // æœ€å¤šç­‰å¾…5ç§’
    
    while (this.loadingQueue.has(cacheKey) && attempts < maxAttempts) {
      await new Promise<void>(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    
    return getData();
  }
}

// è·å–ç¼“å­˜ç®¡ç†å™¨å®ä¾‹
const messageCacheManager = MessagePageCacheManager.getInstance();

class WeatherInfo {
  city: string = 'åŠ è½½ä¸­';
  temperature: string = '--Â°';
  icon: string = 'â“';
  desc: string = 'åŠ è½½ä¸­';
}

class MessageItem {
  avatar: Resource = $r('app.media.splash');
  name: string = '';
  desc: string = '';
  time: string = '';
  followed: boolean = false;
  unread: number = 0;
  isOfficial?: boolean = false;
  isSystem?: boolean = false;
}

@Entry
@Component
export struct MessagePage {
  @State weatherInfo: WeatherInfo = new WeatherInfo();
  @State currentTime: string = '';
  @State currentDate: string = '';
  @State private conversations: Conversation[] = [];
  @State private aiRoleMap: Record<number, AiRole> = {};
  @State arcRotation: number = 0 // åœ†å¼§æ—‹è½¬è§’åº¦
  @State starTwinkle: number = 0 // æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœ
  @State glowOpacity: number = 0.5 // å‘å…‰æ•ˆæœé€æ˜åº¦
  @State textOpacity: number = 0.8 // æ–‡å­—é€æ˜åº¦
  @State nebulaOpacity: number = 0.3 // æ˜Ÿäº‘é€æ˜åº¦
  @State private isLoading: boolean = false; // åŠ è½½çŠ¶æ€
  @State private cacheStats: CacheStats = { total: 0, success: 0, failed: 0, loading: 0 }; // ç¼“å­˜ç»Ÿè®¡
  @State private longPressTimer: number = -1; // é•¿æŒ‰å®šæ—¶å™¨
  @State private isLongPressing: boolean = false; // æ˜¯å¦æ­£åœ¨é•¿æŒ‰
  @State private showLongPressHint: boolean = false; // æ˜¾ç¤ºé•¿æŒ‰æç¤º
  @State private isRefreshing: boolean = false;
  @State private scrollY: number = 0;
  @State private pulling: boolean = false;
  @State private pullStartY: number = 0;

  private timerId: number = -1;

  aboutToAppear() {
    this.startGalaxyAnimations()
    this.loadDataWithCache();
    this.updateDateTime();
    this.timerId = setInterval(() => {
      this.updateDateTime();
    }, 1000);
    
    // å®šæœŸæ¸…ç†ç¼“å­˜
    setInterval(() => {
      messageCacheManager.cleanExpiredCache();
      this.cacheStats = messageCacheManager.getCacheStats();
    }, 60000); // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
  }

  private startGalaxyAnimations() {
    // åœ†å¼§æ—‹è½¬åŠ¨ç”»
    setInterval(() => {
      this.arcRotation += 1.5
    }, 50)
    
    // æ˜Ÿæ˜Ÿé—ªçƒåŠ¨ç”»
    setInterval(() => {
      this.starTwinkle += 0.1
    }, 100)
    
    // å‘å…‰æ•ˆæœåŠ¨ç”»
    setInterval(() => {
      this.glowOpacity = this.glowOpacity === 0.5 ? 0.8 : 0.5
    }, 1200)
    
    // æ–‡å­—é€æ˜åº¦åŠ¨ç”»
    setInterval(() => {
      this.textOpacity = this.textOpacity === 0.8 ? 1.0 : 0.8
    }, 1800)
    
    // æ˜Ÿäº‘é€æ˜åº¦åŠ¨ç”»
    setInterval(() => {
      this.nebulaOpacity = this.nebulaOpacity === 0.3 ? 0.6 : 0.3
    }, 3000)
  }

  // æ–°å¢ï¼šé¡µé¢æ˜¾ç¤ºæ—¶åˆ·æ–°å¯¹è¯åˆ—è¡¨
  onPageShow() {
    console.log('Messageé¡µé¢æ˜¾ç¤ºï¼Œåˆ·æ–°å¯¹è¯åˆ—è¡¨');
    this.loadDataWithCache();
  }

  aboutToDisappear() {
    // æ¸…ç†å®šæ—¶å™¨
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
  }

  updateDateTime() {
    const now = new Date();
    
    // æ ¼å¼åŒ–æ—¶é—´ HH:MM
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    this.currentTime = `${hours}:${minutes}`;
    
    // æ ¼å¼åŒ–æ—¥æœŸå’Œæ˜ŸæœŸ
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    const weekdays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
    const weekday = weekdays[now.getDay()];
    this.currentDate = `${year}å¹´${month}æœˆ${day}æ—¥ ${weekday}`;
  }

  /**
   * ç±»å‹æ£€æŸ¥æ–¹æ³•
   */
  private isConversationArray(value: Conversation[] | ErrorResult): boolean {
    return Array.isArray(value);
  }

  private isWeatherInfo(value: WeatherInfo | ErrorResult): boolean {
    return value !== null && 
           typeof value === 'object' && 
           this.hasProperty(value, 'city') && 
           this.hasProperty(value, 'temperature') && 
           this.hasProperty(value, 'icon') && 
           this.hasProperty(value, 'desc');
  }

  private hasProperty(obj: object, prop: string): boolean {
    try {
      return obj[prop] !== undefined;
    } catch {
      return false;
    }
  }

  /**
   * åˆ é™¤å¯¹è¯
   */
  async deleteConversation(conversation: Conversation) {
    try {
      console.log('ğŸ—‘ï¸ å¼€å§‹åˆ é™¤å¯¹è¯:', conversation.id);
      
      // è°ƒç”¨APIåˆ é™¤å¯¹è¯
      const success = await ApiService.deleteConversation(conversation.id);
      
      if (success) {
        console.log('âœ… å¯¹è¯åˆ é™¤æˆåŠŸ');
        
        // ä»æœ¬åœ°åˆ—è¡¨ä¸­ç§»é™¤å¯¹è¯
        const index = this.conversations.findIndex(conv => conv.id === conversation.id);
        if (index !== -1) {
          this.conversations.splice(index, 1);
        }
        
        // æ¸…é™¤ç¼“å­˜ä¸­çš„ç›¸å…³æ•°æ®
        const userId = getUserId();
        if (userId !== null) {
          messageCacheManager.clearUserCache(userId);
        }
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        prompt.showToast({
          message: 'å¯¹è¯åˆ é™¤æˆåŠŸ',
          duration: 2000
        });
      } else {
        console.error('âŒ å¯¹è¯åˆ é™¤å¤±è´¥');
        prompt.showToast({
          message: 'åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•',
          duration: 2000
        });
      }
    } catch (error) {
      console.error('âŒ åˆ é™¤å¯¹è¯æ—¶å‘ç”Ÿé”™è¯¯:', error);
      prompt.showToast({
        message: 'åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥',
        duration: 2000
      });
    }
  }

  /**
   * æ˜¾ç¤ºåˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
   */
  showDeleteConfirmDialog(conversation: Conversation) {
    // ç›´æ¥æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
    prompt.showDialog({
      title: 'åˆ é™¤å¯¹è¯',
      message: `ç¡®å®šè¦åˆ é™¤å¯¹è¯"${conversation.title}"å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`,
      buttons: [
        {
          text: 'å–æ¶ˆ',
          color: '#666666'
        },
        {
          text: 'åˆ é™¤',
          color: '#ff4444'
        }
      ]
    }).then((result) => {
      if (result.index === 1) { // ç‚¹å‡»äº†åˆ é™¤æŒ‰é’®
        this.deleteConversation(conversation);
      }
    }).catch((error: Error) => {
      console.error('æ˜¾ç¤ºåˆ é™¤ç¡®è®¤å¯¹è¯æ¡†å¤±è´¥:', error);
    });
  }

  /**
   * ä½¿ç”¨ç¼“å­˜åŠ è½½æ•°æ®
   */
  async loadDataWithCache() {
    try {
      this.isLoading = true;
      
      // è·å–å…¨å±€ç”¨æˆ·ID
      const userId = getUserId();
      
      // æ£€æŸ¥ç”¨æˆ·IDæ˜¯å¦æœ‰æ•ˆ
      if (userId === null) {
        console.warn('ç”¨æˆ·IDä¸ºç©ºï¼Œæ— æ³•åŠ è½½å¯¹è¯åˆ—è¡¨');
        this.conversations = [];
        this.aiRoleMap = {};
        this.isLoading = false;
        return;
      }
      
      console.log('ğŸš€ å¼€å§‹ä½¿ç”¨ç¼“å­˜åŠ è½½æ•°æ®ï¼Œç”¨æˆ·ID:', userId);
      
      // å¹¶è¡ŒåŠ è½½æ•°æ®
      const conversationsPromise = messageCacheManager.getConversations(userId);
      const weatherInfoPromise = messageCacheManager.getWeatherInfo();
      
      const conversations = await conversationsPromise.catch((error: string) => {
        console.error('âŒ å¯¹è¯åˆ—è¡¨åŠ è½½å¤±è´¥:', error);
        const errorResult: ErrorResult = { status: 'rejected', reason: error };
        return errorResult;
      });
      const weatherInfo = await weatherInfoPromise.catch((error: string) => {
        console.error('âŒ å¤©æ°”ä¿¡æ¯åŠ è½½å¤±è´¥:', error);
        const errorResult: ErrorResult = { status: 'rejected', reason: error };
        return errorResult;
      });
      
      // å¤„ç†å¯¹è¯åˆ—è¡¨
      if (conversations && this.isConversationArray(conversations)) {
        this.conversations = conversations as Conversation[];
        console.log('âœ… å¯¹è¯åˆ—è¡¨åŠ è½½æˆåŠŸï¼Œæ•°é‡:', this.conversations.length);
        
        // æ‰¹é‡åŠ è½½AIè§’è‰²ä¿¡æ¯
        if (this.conversations.length > 0) {
          const aiRoleIdsSet = new Set<number>();
          for (const conv of this.conversations) {
            aiRoleIdsSet.add(conv.aiRoleId);
          }
          const aiRoleIds: number[] = [];
          for (const id of aiRoleIdsSet) {
            aiRoleIds.push(id);
          }
          const aiRoleMap = await messageCacheManager.getAiRolesBatch(aiRoleIds);
          const entries = aiRoleMap.entries();
          const obj: Record<number, AiRole> = {};
          for (const entry of entries) {
            obj[entry[0]] = entry[1];
          }
          this.aiRoleMap = obj;
          
          // é¢„åŠ è½½å¤´åƒ
          const aiRoles: AiRole[] = [];
          for (const role of aiRoleMap.values()) {
            aiRoles.push(role);
          }
          messageCacheManager.preloadAvatars(aiRoles);
        }
      } else {
        const errorResult = conversations as ErrorResult;
        console.error('âŒ å¯¹è¯åˆ—è¡¨åŠ è½½å¤±è´¥:', errorResult.reason);
        this.conversations = [];
      }
      
      // å¤„ç†å¤©æ°”ä¿¡æ¯
      if (weatherInfo && this.isWeatherInfo(weatherInfo)) {
        this.weatherInfo = weatherInfo as WeatherInfo;
        console.log('âœ… å¤©æ°”ä¿¡æ¯åŠ è½½æˆåŠŸ');
      } else {
        const errorResult = weatherInfo as ErrorResult;
        console.error('âŒ å¤©æ°”ä¿¡æ¯åŠ è½½å¤±è´¥:', errorResult.reason);
      }
      
      // æ›´æ–°ç¼“å­˜ç»Ÿè®¡
      this.cacheStats = messageCacheManager.getCacheStats();
      
    } catch (error) {
      console.error('âŒ æ•°æ®åŠ è½½å¤±è´¥:', error);
      this.conversations = [];
      this.aiRoleMap = {};
    } finally {
      this.isLoading = false;
    }
  }

  refreshConversations() {
    if (this.isRefreshing) return;
    this.isRefreshing = true;
    const userId = getUserId();
    if (userId !== null) {
      messageCacheManager.clearUserCache(userId);
      this.isLoading = true;
      this.loadDataWithCache().then(() => {
        this.isRefreshing = false;
      }).catch(() => {
        this.isRefreshing = false;
      });
    } else {
      this.isRefreshing = false;
    }
  }

  build(): void {
    Stack() {
      // æ·±è‰²æ¸å˜èƒŒæ™¯ - æ”¹ä¸ºçº¯é»‘è‰²ä¸»é¢˜
      Column()
        .width('100%')
        .height('100%')
        .linearGradient({
          direction: GradientDirection.Bottom,
          colors: [['#000000', 0.0], ['#0a0a0a', 0.5], ['#1a1a1a', 1.0]]
        })
      
      // æ—‹è½¬çš„åœ†å¼§èƒŒæ™¯ - æ”¹ä¸ºé»‘è‰²ç³»è£…é¥°
      Stack() {
        // å¤šä¸ªåŒå¿ƒåœ†å¼§è½¨é“
        ForEach([0, 1, 2, 3], (index: number) => {
          Stack() {
            // åœ†å¼§è½¨é“ - æ”¹ä¸ºæ·±ç°è‰²
            Column()
              .width(250 + index * 60)
              .height(250 + index * 60)
              .borderRadius((250 + index * 60) / 2)
              .border({ width: 1, color: `rgba(64, 64, 64, ${0.3 - index * 0.05})` })
              .position({ x: '50%', y: '50%' })
              .translate({ x: -(250 + index * 60) / 2, y: -(250 + index * 60) / 2 })
            
            // æ—‹è½¬çš„åœ†å¼§ç‚¹ - æ”¹ä¸ºç™½è‰²ç³»
            Column()
              .width(6)
              .height(6)
              .backgroundColor(`rgba(255, 255, 255, ${0.6 - index * 0.1})`)
              .borderRadius(3)
              .position({ x: '50%', y: '50%' })
              .translate({ 
                x: -3 + Math.cos((this.arcRotation + index * 90) * Math.PI / 180) * (125 + index * 30),
                y: -3 + Math.sin((this.arcRotation + index * 90) * Math.PI / 180) * (125 + index * 30)
              })
          }
        })
        
        // å¤–åœˆè£…é¥°ç‚¹ - æ”¹ä¸ºé“¶è‰²ç³»
        ForEach([0, 1, 2, 3, 4, 5], (index: number) => {
          Column()
            .width(6)
            .height(6)
            .backgroundColor(`rgba(192, 192, 192, ${0.4 - index * 0.05})`)
            .borderRadius(3)
            .position({ x: '50%', y: '50%' })
            .translate({ 
              x: -3 + Math.cos((this.arcRotation * 0.5 + index * 60) * Math.PI / 180) * 120,
              y: -3 + Math.sin((this.arcRotation * 0.5 + index * 60) * Math.PI / 180) * 120
            })
        })
      }
      .width('100%')
      .height('100%')
      
      // ä¸»è¦å†…å®¹åŒºåŸŸ
      Column() {
        // å¤©æ°”å¡ç‰‡éƒ¨åˆ†
        Stack() {
          // å¤©æ°”å¡ç‰‡èƒŒæ™¯å‘å…‰æ•ˆæœ
          Column()
            .width('100%')
            .height(160)
            .backgroundColor(`rgba(255, 255, 255, ${this.glowOpacity * 0.05})`)
            .borderRadius(24)
            .border({ width: 2, color: `rgba(255, 255, 255, ${this.glowOpacity * 0.2})` })
          
          Column() {
            // ä¸ŠåŠéƒ¨åˆ†ï¼šæ¸©åº¦ã€åŸå¸‚ã€å¤©æ°”æè¿°å’Œå›¾æ ‡
            Row() {
              // å·¦ä¾§ï¼šæ¸©åº¦
              Text(this.weatherInfo.temperature)
                .fontSize(42)
                .fontWeight(FontWeight.Bold)
                .fontColor('#ffffff')
                .opacity(this.textOpacity)
                .margin({ left: 20, top: 16, bottom: 0, right: 0 })
              
              // ä¸­é—´ï¼šåŸå¸‚å’Œå¤©æ°”æè¿°
              Column() {
                Text(this.weatherInfo.city)
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .fontColor('#ffffff')
                  .opacity(this.textOpacity)
                  .margin({ bottom: 4 })
                Text(this.weatherInfo.desc)
                  .fontSize(14)
                  .fontColor('rgba(255, 255, 255, 0.9)')
                  .opacity(this.textOpacity)
                  .margin({ bottom: 0 })
              }
              .alignItems(HorizontalAlign.Start)
              .margin({ left: 16, top: 16, bottom: 0, right: 0 })
              
              // å³ä¾§ï¼šå¤©æ°”å›¾æ ‡
              Blank().layoutWeight(1)
              Text(this.weatherInfo.icon)
                .fontSize(36)
                .fontColor('#ffffff')
                .opacity(this.textOpacity)
                .margin({ right: 20, top: 16, bottom: 0 })
            }
            .width('100%')
            .height(60)
            
            // ä¸‹åŠéƒ¨åˆ†ï¼šæ—¶é—´æ—¥æœŸ
            Column() {
              Text(this.currentTime)
                .fontSize(24)
                .fontColor('#ffffff')
                .fontWeight(FontWeight.Bold)
                .opacity(this.textOpacity)
                .margin({ top: 8, bottom: 4 })
              Text(this.currentDate)
                .fontSize(13)
                .fontColor('rgba(255, 255, 255, 0.8)')
                .opacity(this.textOpacity)
                .margin({ bottom: 16 })
            }
            .alignItems(HorizontalAlign.Center)
            .width('100%')
          }
          .width('100%')
          .height(160)
          .backgroundColor('rgba(255, 255, 255, 0.03)')
          .borderRadius(24)
          .border({ width: 1, color: 'rgba(255, 255, 255, 0.1)' })
          .margin({ left: 12, right: 12, top: 12, bottom: 16 })
          .shadow({ radius: 16, color: '#00000040', offsetX: 0, offsetY: 6 })
        }
        

        
        // æ¶ˆæ¯åˆ—è¡¨
        if (this.isLoading) {
          // åŠ è½½çŠ¶æ€
          Column() {
            // åŠ è½½åŠ¨ç”»
            Stack() {
              Column()
                .width(60)
                .height(60)
                .backgroundColor(`rgba(255, 255, 255, ${this.glowOpacity * 0.1})`)
                .borderRadius(30)
                .border({ width: 2, color: `rgba(255, 255, 255, ${this.glowOpacity * 0.3})` })
              
              Text('â³')
                .fontSize(30)
                .fontColor('#ffffff')
                .opacity(this.textOpacity)
            }
            .margin({ top: 100, bottom: 24 })
            
            Text('æ­£åœ¨åŠ è½½å¯¹è¯...')
              .fontSize(16)
              .fontColor('#ffffff')
              .opacity(this.textOpacity)
          }
          .width('100%')
          .layoutWeight(1)
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
          .padding({ bottom: 56 })
        } else if (this.conversations.length > 0) {
          Scroll() {
            Column() {
              ForEach(this.conversations, (conv: Conversation, idx: number) => {
                ListItem() {
                  Stack() {
                    // æ¶ˆæ¯å¡ç‰‡èƒŒæ™¯å‘å…‰
                    Column()
                      .width('100%')
                      .height(80)
                      .backgroundColor(`rgba(255, 255, 255, ${this.glowOpacity * 0.02})`)
                      .borderRadius(16)
                      .border({ width: 1, color: `rgba(255, 255, 255, ${this.glowOpacity * 0.1})` })
                    
                    Row() {
                      // ä½¿ç”¨æ™ºèƒ½å¤´åƒç»„ä»¶
                      if (this.aiRoleMap[conv.aiRoleId]?.avatarUrl) {
                        Image(this.aiRoleMap[conv.aiRoleId].avatarUrl)
                          .width(48)
                          .height(48)
                          .borderRadius(24)
                          .border({ width: 2, color: 'rgba(255, 255, 255, 0.2)' })
                          .margin({ left: 16, right: 12 })
                          .alt('å¤´åƒåŠ è½½ä¸­...')
                      } else {
                        // é»˜è®¤å¤´åƒ
                        Image($r('app.media.splash'))
                          .width(48)
                          .height(48)
                          .borderRadius(24)
                          .border({ width: 2, color: 'rgba(255, 255, 255, 0.2)' })
                          .margin({ left: 16, right: 12 })
                      }
                      
                      Column({ space: 4 }) {
                        Text(conv.title)
                          .fontSize(16)
                          .fontColor('#ffffff')
                          .fontWeight(FontWeight.Bold)
                          .opacity(this.textOpacity)
                        Text('') // å¯æ‰©å±•ä¸ºæ‘˜è¦
                          .fontSize(13)
                          .fontColor('rgba(255, 255, 255, 0.7)')
                          .maxLines(1)
                          .margin({ top: 2 })
                      }
                      .layoutWeight(1)
                      Column() {
                        Text(conv.lastActive ? conv.lastActive.replace('T', ' ').slice(0, 16) : '')
                          .fontSize(12)
                          .fontColor('rgba(255, 255, 255, 0.6)')
                          .margin({ bottom: 8 })
                      }
                      .alignItems(HorizontalAlign.End)
                      .margin({ right: 16 })
                    }
                    .width('100%')
                    .height(80)
                    .backgroundColor('rgba(255, 255, 255, 0.03)')
                    .borderRadius(16)
                    .border({ width: 1, color: 'rgba(255, 255, 255, 0.1)' })
                    .margin({ left: 12, right: 12, bottom: 8 })
                    .shadow({ radius: 8, color: '#00000020', offsetX: 0, offsetY: 2 })
                  }
                  .onTouch((event: TouchEvent) => {
                    if (event.type === TouchType.Down) {
                      // å¼€å§‹é•¿æŒ‰æ£€æµ‹
                      this.isLongPressing = false;
                      this.showLongPressHint = false;
                      this.longPressTimer = setTimeout(() => {
                        this.isLongPressing = true;
                        this.showLongPressHint = true;
                        // æ˜¾ç¤ºé•¿æŒ‰æç¤º
                        prompt.showToast({
                          message: 'é•¿æŒ‰å¯åˆ é™¤å¯¹è¯',
                          duration: 1000
                        });
                        // å»¶è¿Ÿæ˜¾ç¤ºåˆ é™¤å¯¹è¯æ¡†
                        setTimeout(() => {
                          this.showDeleteConfirmDialog(conv);
                        }, 500);
                      }, 800); // 800msé•¿æŒ‰æ—¶é—´
                    } else if (event.type === TouchType.Up || event.type === TouchType.Cancel) {
                      // ç»“æŸè§¦æ‘¸ï¼Œæ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
                      if (this.longPressTimer !== -1) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = -1;
                      }
                      this.showLongPressHint = false;
                    }
                  })
                  .onClick(() => {
                    // åªæœ‰åœ¨æ²¡æœ‰é•¿æŒ‰çš„æƒ…å†µä¸‹æ‰æ‰§è¡Œå•å‡»
                    if (!this.isLongPressing) {
                      const aiRole = this.aiRoleMap[conv.aiRoleId];
                      console.log('è§’è‰²ID:', aiRole.id);
                      router.pushUrl({
                        url: 'pages/chat',
                        params: {
                          figureImageUrl: aiRole?.avatarUrl ,
                          figureType: aiRole?.roleType ,
                          figureName: aiRole?.roleName ,
                          isFromCreateFigure: false,
                          description: aiRole?.roleDescription ,
                          createdAiRoleId: aiRole?.id
                        }
                      });
                    }
                    // é‡ç½®é•¿æŒ‰çŠ¶æ€
                    this.isLongPressing = false;
                  })
                }
              }, (conv: Conversation) => conv.id.toString())
            }
          }
          .width('100%')
          .layoutWeight(1)
          .onScroll((xOffset: number, yOffset: number) => {
            this.scrollY = yOffset;
          })
          .onTouch((event: TouchEvent) => {
            if (event.type === TouchType.Down && this.scrollY <= 0) {
              this.pulling = true;
              this.pullStartY = event.touches[0].y;
            } else if (event.type === TouchType.Move && this.pulling) {
              const deltaY = event.touches[0].y - this.pullStartY;
              if (deltaY > 80) { // ä¸‹æ‹‰è¶…è¿‡80åƒç´ è§¦å‘åˆ·æ–°
                this.pulling = false;
                this.refreshConversations();
              }
            } else if (event.type === TouchType.Up || event.type === TouchType.Cancel) {
              this.pulling = false;
            }
          })
        } else {
          // ç©ºçŠ¶æ€æ˜¾ç¤º
          Column() {
            // å‘å…‰åœ†åœˆ
            Stack() {
              Column()
                .width(140)
                .height(140)
                .backgroundColor(`rgba(255, 255, 255, ${this.glowOpacity * 0.05})`)
                .borderRadius(70)
                .border({ width: 2, color: `rgba(255, 255, 255, ${this.glowOpacity * 0.2})` })
              
              Text('ğŸ’¬')
                .fontSize(70)
                .fontColor('#ffffff')
                .opacity(this.textOpacity)
            }
            .margin({ top: 100, bottom: 24 })
            
            Text('æš‚æ— å¯¹è¯è®°å½•')
              .fontSize(18)
              .fontWeight(FontWeight.Medium)
              .fontColor('#ffffff')
              .opacity(this.textOpacity)
              .margin({ bottom: 12 })
            
            Text('å¼€å§‹ä¸AIè§’è‰²èŠå¤©ï¼Œåˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªå¯¹è¯å§ï¼')
              .fontSize(14)
              .fontColor('rgba(255, 255, 255, 0.7)')
              .textAlign(TextAlign.Center)
              .opacity(this.textOpacity)
              .margin({ left: 40, right: 40 })
          }
          .width('100%')
          .layoutWeight(1)
          .justifyContent(FlexAlign.Center)
          .alignItems(HorizontalAlign.Center)
        }
      }
      .width('100%')
      .height('100%')
    }
    .width('100%')
    .height('100%')
    
    
  }
} 