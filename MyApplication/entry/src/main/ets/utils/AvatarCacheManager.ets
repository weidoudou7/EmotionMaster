import { AiRole } from '../common/types';
import http from '@ohos.net.http';

// å¤´åƒç¼“å­˜é¡¹æ¥å£
interface AvatarCacheItem {
  url: string;
  data: string; // base64ç¼–ç çš„å›¾ç‰‡æ•°æ®
  timestamp: number;
  size: number;
  loading: boolean;
  failed: boolean;
  retryCount: number;
}

// ç¼“å­˜ç»Ÿè®¡æ¥å£
interface CacheStats {
  total: number;
  success: number;
  failed: number;
  loading: number;
}

// å¤´åƒåŠ è½½çŠ¶æ€
export enum AvatarLoadState {
  LOADING = 'loading',
  LOADED = 'loaded',
  FAILED = 'failed',
  CACHED = 'cached'
}

// æ™ºèƒ½å¤´åƒç»„ä»¶æ¥å£
interface SmartAvatarComponent {
  url: string;
  roleId: number;
  size: number;
  borderRadius: number;
  state: AvatarLoadState;
  retryCount: number;
  load(): Promise<void>;
}

// Base64å­—ç¬¦é›†
const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

// æ™ºèƒ½å¤´åƒç»„ä»¶ç±»å®ç°
class SmartAvatarComponentImpl implements SmartAvatarComponent {
  url: string;
  roleId: number;
  size: number;
  borderRadius: number;
  state: AvatarLoadState;
  retryCount: number;

  constructor(avatarUrl: string, roleId: number, size: number, borderRadius: number) {
    this.url = avatarUrl;
    this.roleId = roleId;
    this.size = size;
    this.borderRadius = borderRadius;
    this.state = AvatarLoadState.LOADING;
    this.retryCount = 0;
  }

  async load(): Promise<void> {
    try {
      this.state = await AvatarCacheManager.getInstance().loadAvatar(this.url, this.roleId);
      
      if (this.state === AvatarLoadState.FAILED && this.retryCount < 3) {
        this.retryCount++;
        console.log(`ğŸ”„ é‡è¯•åŠ è½½å¤´åƒ: ${this.roleId}, ç¬¬ ${this.retryCount} æ¬¡`);
        await new Promise<void>(resolve => setTimeout(resolve, 1000 * this.retryCount));
        await this.load();
      }
    } catch (error) {
      console.error(`âŒ å¤´åƒåŠ è½½å¤±è´¥: ${this.roleId}`, error);
      this.state = AvatarLoadState.FAILED;
    }
  }
}

// å¤´åƒç¼“å­˜ç®¡ç†å™¨
export class AvatarCacheManager {
  private static instance: AvatarCacheManager;
  private cache: Map<string, AvatarCacheItem> = new Map();
  private loadingQueue: Set<string> = new Set();
  private maxCacheSize: number = 50; // æœ€å¤§ç¼“å­˜æ•°é‡
  private maxCacheAge: number = 24 * 60 * 60 * 1000; // 24å°æ—¶ç¼“å­˜è¿‡æœŸæ—¶é—´
  private retryLimit: number = 3; // æœ€å¤§é‡è¯•æ¬¡æ•°
  private preloadQueue: string[] = []; // é¢„åŠ è½½é˜Ÿåˆ—

  // å•ä¾‹æ¨¡å¼
  public static getInstance(): AvatarCacheManager {
    if (!AvatarCacheManager.instance) {
      AvatarCacheManager.instance = new AvatarCacheManager();
    }
    return AvatarCacheManager.instance;
  }

  /**
   * æ™ºèƒ½å¤´åƒåŠ è½½ - ä¸»è¦æ¥å£
   */
  public async loadAvatar(avatarUrl: string, roleId: number): Promise<AvatarLoadState> {
    if (!avatarUrl || avatarUrl.trim() === '') {
      return AvatarLoadState.FAILED;
    }

    const cacheKey = this.generateCacheKey(avatarUrl, roleId);
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(cacheKey);
    if (cached && !this.isExpired(cached)) {
      console.log(`ğŸ¯ å¤´åƒç¼“å­˜å‘½ä¸­: ${roleId}`);
      return AvatarLoadState.CACHED;
    }

    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    if (this.loadingQueue.has(cacheKey)) {
      console.log(`â³ å¤´åƒæ­£åœ¨åŠ è½½ä¸­: ${roleId}`);
      return AvatarLoadState.LOADING;
    }

    // å¼€å§‹åŠ è½½
    return this.startLoading(cacheKey, avatarUrl, roleId);
  }

  /**
   * è·å–ç¼“å­˜çš„å¤´åƒæ•°æ®
   */
  public getCachedAvatar(avatarUrl: string, roleId: number): string | null {
    const cacheKey = this.generateCacheKey(avatarUrl, roleId);
    const cached = this.cache.get(cacheKey);
    
    if (cached && !this.isExpired(cached) && !cached.failed) {
      return cached.data;
    }
    
    return null;
  }

  /**
   * é¢„åŠ è½½å¤´åƒåˆ—è¡¨
   */
  public async preloadAvatars(aiRoles: AiRole[]): Promise<void> {
    console.log(`ğŸš€ å¼€å§‹é¢„åŠ è½½ ${aiRoles.length} ä¸ªå¤´åƒ`);
    
    // è¿‡æ»¤å‡ºéœ€è¦é¢„åŠ è½½çš„å¤´åƒ
    const toPreload: AiRole[] = [];
    for (const role of aiRoles) {
      const cacheKey = this.generateCacheKey(role.avatarUrl, role.id || 0);
      const cached = this.cache.get(cacheKey);
      if (!cached || this.isExpired(cached) || cached.failed) {
        toPreload.push(role);
      }
    }

    // åˆ†æ‰¹é¢„åŠ è½½ï¼Œé¿å…åŒæ—¶åŠ è½½è¿‡å¤š
    const batchSize = 3;
    for (let i = 0; i < toPreload.length; i += batchSize) {
      const batch = toPreload.slice(i, i + batchSize);
      const promises: Promise<AvatarLoadState>[] = [];
      for (const role of batch) {
        promises.push(this.loadAvatar(role.avatarUrl, role.id || 0));
      }
      
      // ç­‰å¾…æ‰€æœ‰promiseå®Œæˆï¼Œå¿½ç•¥é”™è¯¯
      for (const promise of promises) {
        try {
          await promise;
        } catch (error) {
          // å¿½ç•¥å•ä¸ªå¤´åƒåŠ è½½å¤±è´¥
        }
      }
      
      // æ‰¹æ¬¡é—´å»¶è¿Ÿï¼Œé¿å…é˜»å¡UI
      if (i + batchSize < toPreload.length) {
        await new Promise<void>(resolve => setTimeout(resolve, 100));
      }
    }
    
    console.log(`âœ… é¢„åŠ è½½å®Œæˆï¼ŒæˆåŠŸåŠ è½½ ${this.getSuccessCount()} ä¸ªå¤´åƒ`);
  }

  /**
   * æ™ºèƒ½å¤´åƒç»„ä»¶ - å¸¦åŠ è½½çŠ¶æ€å’ŒåŠ¨ç”»
   */
  public createSmartAvatarComponent(
    avatarUrl: string, 
    roleId: number, 
    size: number = 48,
    borderRadius: number = 24
  ): SmartAvatarComponent {
    return new SmartAvatarComponentImpl(avatarUrl, roleId, size, borderRadius);
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  public cleanExpiredCache(): void {
    const now = Date.now();
    let cleanedCount = 0;
    
    const keysToDelete: string[] = [];
    for (const entry of this.cache.entries()) {
      const key = entry[0];
      const item = entry[1];
      if (this.isExpired(item)) {
        keysToDelete.push(key);
      }
    }
    
    for (const key of keysToDelete) {
      this.cache.delete(key);
      cleanedCount++;
    }
    
    if (cleanedCount > 0) {
      console.log(`ğŸ§¹ æ¸…ç†äº† ${cleanedCount} ä¸ªè¿‡æœŸç¼“å­˜`);
    }
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  public getCacheStats(): CacheStats {
    let success = 0, failed = 0, loading = 0;
    
    for (const item of this.cache.values()) {
      if (item.loading) loading++;
      else if (item.failed) failed++;
      else success++;
    }
    
    const stats: CacheStats = {
      total: this.cache.size,
      success: success,
      failed: failed,
      loading: loading
    };
    return stats;
  }

  // ==================== ç§æœ‰æ–¹æ³• ====================

  private async startLoading(cacheKey: string, avatarUrl: string, roleId: number): Promise<AvatarLoadState> {
    this.loadingQueue.add(cacheKey);
    
    try {
      console.log(`ğŸ“¥ å¼€å§‹åŠ è½½å¤´åƒ: ${roleId}`);
      
      // åˆ›å»ºç¼“å­˜é¡¹
      const cacheItem: AvatarCacheItem = {
        url: avatarUrl,
        data: '',
        timestamp: Date.now(),
        size: 0,
        loading: true,
        failed: false,
        retryCount: 0
      };
      
      this.cache.set(cacheKey, cacheItem);
      
      // ä½¿ç”¨httpæ¨¡å—åŠ è½½å›¾ç‰‡
      const httpRequest = http.createHttp();
      const response = await httpRequest.request(avatarUrl, {
        method: http.RequestMethod.GET,
        readTimeout: 10000,
        connectTimeout: 5000
      });
      httpRequest.destroy();
      
      if (response.responseCode !== 200) {
        throw new Error(`HTTP ${response.responseCode}: è¯·æ±‚å¤±è´¥`);
      }
      
      const imageData = response.result as ArrayBuffer;
      const base64 = this.arrayBufferToBase64(imageData);
      
      // æ›´æ–°ç¼“å­˜
      cacheItem.data = base64;
      cacheItem.size = imageData.byteLength;
      cacheItem.loading = false;
      cacheItem.failed = false;
      
      // ç®¡ç†ç¼“å­˜å¤§å°
      this.manageCacheSize();
      
      console.log(`âœ… å¤´åƒåŠ è½½æˆåŠŸ: ${roleId}, å¤§å°: ${(imageData.byteLength / 1024).toFixed(1)}KB`);
      return AvatarLoadState.LOADED;
      
    } catch (error) {
      console.error(`âŒ å¤´åƒåŠ è½½å¤±è´¥: ${roleId}`, error);
      
      // æ›´æ–°å¤±è´¥çŠ¶æ€
      const cacheItem = this.cache.get(cacheKey);
      if (cacheItem) {
        cacheItem.loading = false;
        cacheItem.failed = true;
        cacheItem.retryCount++;
      }
      
      return AvatarLoadState.FAILED;
    } finally {
      this.loadingQueue.delete(cacheKey);
    }
  }

  private generateCacheKey(avatarUrl: string, roleId: number): string {
    return `${roleId}_${this.hashString(avatarUrl)}`;
  }

  private isExpired(cacheItem: AvatarCacheItem): boolean {
    return Date.now() - cacheItem.timestamp > this.maxCacheAge;
  }

  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return 'data:image/jpeg;base64,' + this.btoa(binary);
  }

  private btoa(str: string): string {
    let output = '';
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    
    let byteNum: number;
    let chunk: string[];
    
    for (let i = 0; i < bytes.length; i += 3) {
      byteNum = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
      chunk = [
        BASE64_CHARS.charAt((byteNum >> 18) & 0x3F),
        BASE64_CHARS.charAt((byteNum >> 12) & 0x3F),
        BASE64_CHARS.charAt((byteNum >> 6) & 0x3F),
        BASE64_CHARS.charAt(byteNum & 0x3F)
      ];
      output += chunk.join('');
    }
    
    return output;
  }

  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return Math.abs(hash).toString(36);
  }

  private manageCacheSize(): void {
    if (this.cache.size <= this.maxCacheSize) return;
    
    // æŒ‰æ—¶é—´æ’åºï¼Œåˆ é™¤æœ€æ—§çš„ç¼“å­˜
    const entries: Array<[string, AvatarCacheItem]> = [];
    for (const entry of this.cache.entries()) {
      const key = entry[0];
      const item = entry[1];
      entries.push([key, item]);
    }
    
    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
    
    const toDelete = entries.slice(0, this.cache.size - this.maxCacheSize);
    for (const entry of toDelete) {
      const key = entry[0];
      this.cache.delete(key);
    }
    
    console.log(`ğŸ—‘ï¸ æ¸…ç†äº† ${toDelete.length} ä¸ªç¼“å­˜é¡¹`);
  }

  private getSuccessCount(): number {
    let count = 0;
    for (const item of this.cache.values()) {
      if (!item.failed && !item.loading) count++;
    }
    return count;
  }
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
export const avatarCacheManager = AvatarCacheManager.getInstance(); 