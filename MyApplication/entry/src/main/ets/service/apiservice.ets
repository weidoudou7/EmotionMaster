import { globalUserData } from '../models/userdata';
import { Config } from '../common/config';
import { UserInfo, UpdateUserRequest, ApiResponse, Dynamic, CreateDynamicRequest, UserStats, MusicDetailVO, SearchUserResult, CreateAiRoleRequest, GenerateRoleNameRequest, CreateConversationRequest, Conversation, Message, CreateMessageRequest, CommentItem, RoleTypeStatistics, UserRolePreferenceAnalysis, PreviewAvatarResponse } from '../common/types';
import {  AiRole } from '../common/types';
import http from '@ohos.net.http';


// APIåŸºç¡€é…ç½® - ä»é…ç½®æ–‡ä»¶è·å–
const API_BASE_URL = Config.getApiBaseUrl();


//const API_BASE_URL = 'http://10.128.156.25:8081/api';

// å®šä¹‰HTTPè¯·æ±‚é€‰é¡¹æ¥å£
interface HttpRequestOptions {
  method?: http.RequestMethod;
  header?: Record<string, string>;
  body?: string;
}

// AIä¸“æ æ–‡ç« æ¥å£è¿”å›ç±»å‹
interface AIArticleResponse {
  content: string;
}

// è¯„è®ºåˆ—è¡¨è¿”å›ç±»å‹
interface CommentListResponse {
  comments: CommentItem[];
  totalCount: number;
  currentPage: number;
  pageSize: number;
}

// å›å¤åˆ—è¡¨è¿”å›ç±»å‹
interface ReplyListResponse {
  replies: CommentItem[];
  totalCount: number;
  currentPage: number;
  pageSize: number;
}

// å‘å¸ƒè¯„è®ºè¿”å›ç±»å‹
interface PublishCommentResponse {
  commentId: number;
  message: string;
}

// å›å¤è¯„è®ºè¿”å›ç±»å‹
interface ReplyCommentResponse {
  replyId: number;
  message: string;
}

// ç‚¹èµæ“ä½œè¿”å›ç±»å‹
interface LikeOperationResponse {
  success: boolean;
  message: string;
}

// åˆ é™¤è¯„è®ºè¿”å›ç±»å‹
interface DeleteCommentResponse {
  success: boolean;
  message: string;
}

// æ£€æŸ¥ç‚¹èµçŠ¶æ€è¿”å›ç±»å‹
interface CheckLikeStatusResponse {
  isLiked: boolean;
}

// å›å¤è¯„è®ºè¯·æ±‚ä½“æ¥å£
interface ReplyCommentRequestBody {
  aiRoleId: number;
  userId: number;
  content: string;
  rootCommentId: number;
  toCommentId?: number;
}

interface ImageMainColorResponse {
  mainColor: string;
}

/**
 * APIæœåŠ¡ç±»
 */
export class ApiService {
  /**
   * é€šç”¨HTTPè¯·æ±‚æ–¹æ³•
   */
  private static async request<T>(
    url: string,
    options: HttpRequestOptions = {}
  ): Promise<ApiResponse<T>> {
    try {

      const httpRequest = http.createHttp();

      // è®¾ç½®è¯·æ±‚å¤´
      const headers: Record<string, string> = {
        'Content-Type': 'application/json'
      };

      // åˆå¹¶è‡ªå®šä¹‰è¯·æ±‚å¤´
      const customHeader = options.header ?? {};
      Object.keys(customHeader).forEach(key => {
        headers[key] = customHeader[key];
      });

      // è®¾ç½®è¯·æ±‚é€‰é¡¹
      const requestOptions: http.HttpRequestOptions = {
        method: options.method || http.RequestMethod.GET,
        header: headers,
        readTimeout: Config.getTimeout(),
        connectTimeout: Config.getTimeout()
      };

      // å¦‚æœæœ‰è¯·æ±‚ä½“ï¼Œæ·»åŠ åˆ°é€‰é¡¹ä¸­
      if (options.body) {
        requestOptions.extraData = options.body;
      }

      const response = await httpRequest.request(url, requestOptions);

      httpRequest.destroy();

      if (response.responseCode !== 200) {
        throw new Error(`HTTP error! status: ${response.responseCode}`);
      }

      let result: ApiResponse<T>;
      try {
        result = JSON.parse(response.result.toString());
        console.log('ğŸŒ JSONè§£ææˆåŠŸ:', result);
      } catch (e) {
        // æ‰“å°åŸå§‹å†…å®¹ï¼Œä¾¿äºè°ƒè¯•
        console.error('ğŸŒ APIè¿”å›å†…å®¹ä¸æ˜¯æ ‡å‡†JSONï¼ŒåŸå§‹å†…å®¹å¦‚ä¸‹:');
        console.error(response.result.toString());
        // ç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œæç¤ºåç«¯è¿”å›å†…å®¹å¼‚å¸¸
        throw new Error('åç«¯è¿”å›å†…å®¹ä¸æ˜¯æ ‡å‡†JSONï¼Œæ— æ³•è§£æ');
      }

      // è°ƒè¯•æ¨¡å¼ä¸‹çš„æ—¥å¿—
      if (Config.isDebug()) {
        console.log(`ğŸŒ APIè¯·æ±‚: ${url}`, result);
      }

      return result;
    } catch (error) {
      console.error('ğŸŒ APIè¯·æ±‚å¤±è´¥:', error);
      if (error instanceof Error) {
        console.error('ğŸŒ error.message:', error.message);
        if (error.stack) {
          console.error('ğŸŒ error.stack:', error.stack);
        }
      } else {
        console.error('ğŸŒ error(éErrorç±»å‹):', JSON.stringify(error));
      }
      try {
        if (typeof error === 'object' && error !== null) {
          const errObj = error as Record<string, string>;
          Object.keys(errObj).forEach((key) => {
            console.error(`ğŸŒ error[${key}]:`, errObj[key]);
          });
        } else {
          console.error('ğŸŒ error(åŸå§‹):', error);
        }
      } catch (e) {
        console.error('ğŸŒ æ‰“å°errorå±æ€§å¤±è´¥:', e);
      }
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  /**
   * è·å–ç”¨æˆ·ä¿¡æ¯
   */
  static async getUserInfo(userUID: string): Promise<UserInfo> {
    const response = await ApiService.request<UserInfo>(`${API_BASE_URL}/user/${userUID}`);
    if (response.success) {
      // å¤„ç†å¤´åƒURL - å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ‹¼æ¥å®Œæ•´URL
      let userInfo = response.data;
      if (userInfo.userAvatar && userInfo.userAvatar.startsWith('/')) {
        const baseUrl = Config.getApiBaseUrl().replace('/api', '');
        userInfo.userAvatar = baseUrl + userInfo.userAvatar;
        console.log('ğŸ‘¤ [ApiService] å¤„ç†åçš„å¤´åƒURL:', userInfo.userAvatar);
      }
      
      // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
      globalUserData.updateUserName(userInfo.userName);
      globalUserData.updateUserUID(userInfo.userUID);
      globalUserData.updateUserAvatar(userInfo.userAvatar);
      if (userInfo.isPrivacyVisible !== globalUserData.isPrivacyVisible) {
        globalUserData.togglePrivacy();
      }
      return userInfo;
    } else {
      throw new Error(response.message || 'Failed to get user info');
    }
  }

  /**
   * è·å–ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
   */
  static async getUserStats(userUID: string): Promise<UserStats> {
    const response = await ApiService.request<UserStats>(`${API_BASE_URL}/user/${userUID}/stats`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get user stats');
    }
  }

  /**
   * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
   */
  static async updateUserInfo(userUID: string, userData: UpdateUserRequest): Promise<UserInfo> {
    const response = await ApiService.request<UserInfo>(`${API_BASE_URL}/user/${userUID}`, {
      method: http.RequestMethod.PUT,
      body: JSON.stringify(userData)
    });

    if (response.success) {
      // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
      if (userData.userName) {
        globalUserData.updateUserName(userData.userName);
      }
      if (userData.userAvatar) {
        globalUserData.updateUserAvatar(userData.userAvatar);
      }
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to update user info');
    }
  }

  /**
   * ä¸Šä¼ ç”¨æˆ·å¤´åƒ (ç®€åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨base64)
   */
  static async uploadAvatar(userUID: string, imageData: string): Promise<string> {
    try {
      const response = await ApiService.request<string>(`${API_BASE_URL}/user/${userUID}/avatar/base64`, {
        method: http.RequestMethod.POST,
        body: JSON.stringify({ imageData: imageData })
      });

      if (response.success) {
        // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
        globalUserData.updateUserAvatar(response.data);
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to upload avatar');
      }
    } catch (error) {
      console.error('å¤´åƒä¸Šä¼ å¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  /**
   * ç”Ÿæˆæ–°çš„éšæœºå¤´åƒ
   */
  static async generateNewAvatar(userUID: string): Promise<string> {
    try {
      console.log('ğŸ¨ [ApiService] å¼€å§‹ç”Ÿæˆæ–°å¤´åƒï¼Œç”¨æˆ·UID:', userUID);
      
      const response = await ApiService.request<string>(`${API_BASE_URL}/user/${userUID}/avatar/generate`, {
        method: http.RequestMethod.POST
      });

      if (response.success) {
        console.log('ğŸ¨ [ApiService] å¤´åƒç”ŸæˆæˆåŠŸï¼ŒåŸå§‹URL:', response.data);
        
        // å¤„ç†å¤´åƒURL - å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ‹¼æ¥å®Œæ•´URL
        let avatarUrl = response.data;
        if (avatarUrl && avatarUrl.startsWith('/')) {
          const baseUrl = Config.getApiBaseUrl().replace('/api', '');
          avatarUrl = baseUrl + avatarUrl;
          console.log('ğŸ¨ [ApiService] æ‹¼æ¥åçš„å®Œæ•´URL:', avatarUrl);
        }
        
        // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
        globalUserData.updateUserAvatar(avatarUrl);
        console.log('ğŸ¨ [ApiService] å…¨å±€çŠ¶æ€å·²æ›´æ–°ï¼Œå¤´åƒURL:', avatarUrl);
        return avatarUrl;
      } else {
        throw new Error(response.message || 'Failed to generate avatar');
      }
    } catch (error) {
      console.error('ğŸ¨ [ApiService] å¤´åƒç”Ÿæˆå¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  /**
   * ç”Ÿæˆé¢„è§ˆå¤´åƒ
   */
  static async generatePreviewAvatar(userUID: string): Promise<PreviewAvatarResponse> {
    try {
      console.log('ğŸ‘ï¸ [ApiService] å¼€å§‹ç”Ÿæˆé¢„è§ˆå¤´åƒï¼Œç”¨æˆ·UID:', userUID);
      
      const response = await ApiService.request<PreviewAvatarResponse>(`${API_BASE_URL}/user/${userUID}/avatar/preview`, {
        method: http.RequestMethod.POST
      });

      if (response.success) {
        console.log('ğŸ‘ï¸ [ApiService] é¢„è§ˆå¤´åƒç”ŸæˆæˆåŠŸ');
        console.log('ğŸ‘ï¸ [ApiService] é¢„è§ˆç§å­:', response.data.previewSeed);
        console.log('ğŸ‘ï¸ [ApiService] é¢„è§ˆå›¾ç‰‡é•¿åº¦:', response.data.previewImage.length);
        
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to generate preview avatar');
      }
    } catch (error) {
      console.error('ğŸ‘ï¸ [ApiService] é¢„è§ˆå¤´åƒç”Ÿæˆå¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  /**
   * ç¡®è®¤å¹¶ä¿å­˜é¢„è§ˆå¤´åƒ
   */
  static async confirmPreviewAvatar(userUID: string, previewSeed: number): Promise<string> {
    try {
      console.log('ğŸ’¾ [ApiService] å¼€å§‹ç¡®è®¤é¢„è§ˆå¤´åƒï¼Œç”¨æˆ·UID:', userUID);
      console.log('ğŸ’¾ [ApiService] é¢„è§ˆç§å­:', previewSeed);
      
      const response = await ApiService.request<string>(`${API_BASE_URL}/user/${userUID}/avatar/confirm?previewSeed=${previewSeed}`, {
        method: http.RequestMethod.POST
      });

      if (response.success) {
        console.log('ğŸ’¾ [ApiService] å¤´åƒç¡®è®¤å¹¶ä¿å­˜æˆåŠŸï¼ŒåŸå§‹URL:', response.data);
        
        // å¤„ç†å¤´åƒURL - å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ‹¼æ¥å®Œæ•´URL
        let avatarUrl = response.data;
        if (avatarUrl && avatarUrl.startsWith('/')) {
          const baseUrl = Config.getApiBaseUrl().replace('/api', '');
          avatarUrl = baseUrl + avatarUrl;
          console.log('ğŸ’¾ [ApiService] æ‹¼æ¥åçš„å®Œæ•´URL:', avatarUrl);
        }
        
        // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
        globalUserData.updateUserAvatar(avatarUrl);
        console.log('ğŸ’¾ [ApiService] å…¨å±€çŠ¶æ€å·²æ›´æ–°ï¼Œå¤´åƒURL:', avatarUrl);
        return avatarUrl;
      } else {
        throw new Error(response.message || 'Failed to confirm preview avatar');
      }
    } catch (error) {
      console.error('ğŸ’¾ [ApiService] ç¡®è®¤é¢„è§ˆå¤´åƒå¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  /**
   * åˆ‡æ¢éšç§å¯è§æ€§
   */
  static async togglePrivacy(userUID: string): Promise<boolean> {
    const response = await ApiService.request<boolean>(`${API_BASE_URL}/user/${userUID}/privacy/toggle`, {
      method: http.RequestMethod.POST
    });

    if (response.success) {
      // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
      globalUserData.togglePrivacy();
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to toggle privacy');
    }
  }

  /**
   * åˆ›å»ºæ–°ç”¨æˆ·
   */
  static async createUser(userUID: string, userName: string): Promise<UserInfo> {
    const response =
      await ApiService.request<UserInfo>(`${API_BASE_URL}/user/create?userUID=${userUID}&userName=${encodeURIComponent(userName)}`,
        {
          method: http.RequestMethod.POST
        });

    if (response.success) {
      // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
      globalUserData.updateUserName(response.data.userName);
      globalUserData.updateUserUID(response.data.userUID);
      globalUserData.updateUserAvatar(response.data.userAvatar);
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to create user');
    }
  }

  /**
   * é€šè¿‡é‚®ç®±åˆ›å»ºæˆ–ç™»å½•ç”¨æˆ·
   */
  static async createOrLoginUserByEmail(email: string): Promise<UserInfo> {
    const response = await ApiService.request<UserInfo>(`${API_BASE_URL}/user/createOrLoginByEmail?email=${encodeURIComponent(email)}`, {
      method: http.RequestMethod.POST
    });

    if (response.success) {
      // åŒæ­¥åˆ°å‰ç«¯å…¨å±€çŠ¶æ€
      globalUserData.updateUserName(response.data.userName);
      globalUserData.updateUserUID(response.data.userUID);
      globalUserData.updateUserAvatar(response.data.userAvatar);
      if (response.data.isPrivacyVisible !== globalUserData.isPrivacyVisible) {
        globalUserData.togglePrivacy();
      }
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to create or login user by email');
    }
  }

  /**
   * æ ¹æ®é‚®ç®±è·å–ç”¨æˆ·ID
   */
  static async getUserIdByEmail(email: string): Promise<number> {
    const response = await ApiService.request<number>(`${API_BASE_URL}/user/getUserIdByEmail?email=${encodeURIComponent(email)}`);

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get user ID by email');
    }
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  static async healthCheck(): Promise<boolean> {
    try {
      const response = await ApiService.request<string>(`${API_BASE_URL}/user/health`);
      return response.success;
    } catch (error) {
      console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * AIèŠå¤©æ¥å£
   */
  static async chatWithAI(prompt: string, chatId: string, identity: string = 'default'): Promise<string> {
    try {
      const url =
        `${API_BASE_URL}/ai/chat/${identity}?prompt=${encodeURIComponent(prompt)}&chatId=${encodeURIComponent(chatId)}`;

      console.log('å‘é€AIèŠå¤©è¯·æ±‚åˆ°:', url);
      console.log('ç”¨æˆ·è¾“å…¥:', prompt);
      console.log('èŠå¤©ID:', chatId);
      console.log('èº«ä»½:', identity);

      const httpRequest = http.createHttp();
      const requestOptions: http.HttpRequestOptions = {
        method: http.RequestMethod.POST,
        header: {
          'Content-Type': 'application/json'
        },
        readTimeout: Config.getTimeout(),
        connectTimeout: Config.getTimeout()
      };

      const response = await httpRequest.request(url, requestOptions);
      httpRequest.destroy();

      console.log('AIèŠå¤©å“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('AIèŠå¤©å“åº”å†…å®¹:', response.result.toString());

      if (response.responseCode !== 200) {
        throw new Error(`HTTP error! status: ${response.responseCode}, message: ${response.result.toString()}`);
      }

      // ç›´æ¥è¿”å›å“åº”å†…å®¹ï¼Œå› ä¸ºåç«¯è¿”å›çš„æ˜¯çº¯æ–‡æœ¬
      const result = response.result.toString();
      console.log('AIå›å¤:', result);
      return result;
    } catch (error) {
      console.error('AIèŠå¤©å¤±è´¥:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        throw new Error(`AIèŠå¤©å¤±è´¥: ${error.message}`);
      } else {
        throw new Error('AIèŠå¤©å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * ç‰¹è‰²èŠå¤©æ¥å£ - ä½¿ç”¨è‡ªå®šä¹‰æè¿°è¯
   */
  static async featuredChat(prompt: string, chatId: string, desc: string): Promise<string> {
    try {
      const url =
        `${API_BASE_URL}/ai/featured_chat?prompt=${encodeURIComponent(prompt)}&chatId=${encodeURIComponent(chatId)}&desc=${encodeURIComponent(desc)}`;

      console.log('å‘é€ç‰¹è‰²èŠå¤©è¯·æ±‚åˆ°:', url);
      console.log('ç”¨æˆ·è¾“å…¥:', prompt);
      console.log('èŠå¤©ID:', chatId);
      console.log('æè¿°è¯:', desc);

      const httpRequest = http.createHttp();
      const requestOptions: http.HttpRequestOptions = {
        method: http.RequestMethod.POST,
        header: {
          'Content-Type': 'application/json'
        },
        readTimeout: Config.getTimeout(),
        connectTimeout: Config.getTimeout()
      };

      const response = await httpRequest.request(url, requestOptions);
      httpRequest.destroy();

      console.log('ç‰¹è‰²èŠå¤©å“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('ç‰¹è‰²èŠå¤©å“åº”å†…å®¹:', response.result.toString());

      if (response.responseCode !== 200) {
        throw new Error(`HTTP error! status: ${response.responseCode}, message: ${response.result.toString()}`);
      }

      // ç›´æ¥è¿”å›å“åº”å†…å®¹ï¼Œå› ä¸ºåç«¯è¿”å›çš„æ˜¯çº¯æ–‡æœ¬
      const result = response.result.toString();
      console.log('AIå›å¤:', result);
      return result;
    } catch (error) {
      console.error('ç‰¹è‰²èŠå¤©å¤±è´¥:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        throw new Error(`ç‰¹è‰²èŠå¤©å¤±è´¥: ${error.message}`);
      } else {
        throw new Error('ç‰¹è‰²èŠå¤©å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * ç”Ÿæˆå½¢è±¡æè¿°æ¥å£
   */
  static async generateDescription(userInput: string): Promise<string> {
    try {
      const url = `${API_BASE_URL}/ai/generate-description?userInput=${encodeURIComponent(userInput)}`;

      console.log('å‘é€è¯·æ±‚åˆ°:', url);
      console.log('ç”¨æˆ·è¾“å…¥:', userInput);

      // æµ‹è¯•è¿æ¥
      const testUrl = `${API_BASE_URL}/user/health`;
      const testRequest = http.createHttp();
      const testResponse = await testRequest.request(testUrl, { method: http.RequestMethod.GET });
      testRequest.destroy();
      console.log('è¿æ¥æµ‹è¯•ç»“æœ:', testResponse.responseCode);

      const httpRequest = http.createHttp();
      const requestOptions: http.HttpRequestOptions = {
        method: http.RequestMethod.POST,
        header: {
          'Content-Type': 'application/json'
        },
        readTimeout: Config.getTimeout(),
        connectTimeout: Config.getTimeout()
      };

      const response = await httpRequest.request(url, requestOptions);
      httpRequest.destroy();

      console.log('å“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('å“åº”å¤´:', JSON.stringify(response.header));
      console.log('å“åº”å†…å®¹é•¿åº¦:', response.result.toString().length);
      console.log('å“åº”å†…å®¹:', response.result.toString());

      if (response.responseCode !== 200) {
        throw new Error(`HTTP error! status: ${response.responseCode}, message: ${response.result.toString()}`);
      }

      // ç›´æ¥è¿”å›å“åº”å†…å®¹ï¼Œå› ä¸ºåç«¯è¿”å›çš„æ˜¯çº¯æ–‡æœ¬
      const result = response.result.toString();
      console.log('ç”Ÿæˆçš„æè¿°:', result);
      return result;
    } catch (error) {
      console.error('ç”Ÿæˆå½¢è±¡æè¿°å¤±è´¥:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      // æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶é”™è¯¯
      if (error && typeof error === 'object') {
        const errorObj = error as Record<string, string | number>;
        if (errorObj.code === 2300028) {
          throw new Error('ç”Ÿæˆæè¿°è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•ã€‚AIç”Ÿæˆéœ€è¦è¾ƒé•¿æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚');
        }
      }

      if (error instanceof Error) {
        throw new Error(`ç”Ÿæˆæè¿°å¤±è´¥: ${error.message}`);
      } else {
        throw new Error('ç”Ÿæˆæè¿°å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * ç”Ÿæˆå½¢è±¡å›¾ç‰‡æ¥å£
   */
  static async generateFigure(userInput: string, style: string): Promise<string> {
    try {
      const url =
        `${API_BASE_URL}/ai/generate-figure?userInput=${encodeURIComponent(userInput)}&style=${encodeURIComponent(style)}`;

      console.log('å‘é€ç”Ÿæˆå›¾ç‰‡è¯·æ±‚åˆ°:', url);
      console.log('ç”¨æˆ·è¾“å…¥:', userInput);
      console.log('é£æ ¼:', style);

      const httpRequest = http.createHttp();
      const requestOptions: http.HttpRequestOptions = {
        method: http.RequestMethod.POST,
        header: {
          'Content-Type': 'application/json'
        },
        readTimeout: 180000, // 3åˆ†é’Ÿè¶…æ—¶ï¼Œä¸“é—¨ç”¨äºå›¾ç‰‡ç”Ÿæˆ
        connectTimeout: 30000 // 30ç§’è¿æ¥è¶…æ—¶
      };

      const response = await httpRequest.request(url, requestOptions);
      httpRequest.destroy();

      console.log('å›¾ç‰‡ç”Ÿæˆå“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('å›¾ç‰‡ç”Ÿæˆå“åº”å†…å®¹:', response.result.toString());

      if (response.responseCode !== 200) {
        throw new Error(`HTTP error! status: ${response.responseCode}, message: ${response.result.toString()}`);
      }

      // ç›´æ¥è¿”å›å“åº”å†…å®¹ï¼Œå› ä¸ºåç«¯è¿”å›çš„æ˜¯å›¾ç‰‡URL
      const result = response.result.toString();
      console.log('ç”Ÿæˆçš„å›¾ç‰‡URL:', result);
      return result;
    } catch (error) {
      console.error('ç”Ÿæˆå½¢è±¡å›¾ç‰‡å¤±è´¥:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      // æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶é”™è¯¯
      if (error && typeof error === 'object') {
        const errorObj = error as Record<string, string | number>;
        if (errorObj.code === 2300028) {
          throw new Error('ç”Ÿæˆå›¾ç‰‡è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•ã€‚AIç”Ÿæˆéœ€è¦è¾ƒé•¿æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚');
        }
      }

      if (error instanceof Error) {
        throw new Error(`ç”Ÿæˆå›¾ç‰‡å¤±è´¥: ${error.message}`);
      } else {
        throw new Error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * è·å–AIèº«ä»½åˆ—è¡¨
   */
  static async getAIIdentities(): Promise<string[]> {
    const response = await ApiService.request<string[]>(`${API_BASE_URL}/ai/identities`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get AI identities');
    }
  }

  /**
   * è·å–å½“å‰æœåŠ¡å™¨åœ°å€
   */
  static getServerUrl(): string {
    return API_BASE_URL;
  }

  /**
   * è·å–å½“å‰ç¯å¢ƒä¿¡æ¯
   */
  static getEnvironmentInfo(): string {
    return `ç¯å¢ƒ: ${Config.getCurrentEnv()}, æœåŠ¡å™¨: ${API_BASE_URL}`;
  }

  /**
   * åˆ›å»ºåŠ¨æ€
   */
  static async createDynamic(userUID: string, dynamicData: CreateDynamicRequest): Promise<Dynamic> {
    console.log('ğŸŒ ApiService.createDynamic å¼€å§‹è°ƒç”¨');
    console.log('ğŸŒ userUID:', userUID);
    console.log('ğŸŒ dynamicData:', JSON.stringify(dynamicData));
    console.log('ğŸŒ è¯·æ±‚URL:', `${API_BASE_URL}/dynamic/create/${userUID}`);

    try {
      const response = await ApiService.request<Dynamic>(`${API_BASE_URL}/dynamic/create/${userUID}`, {
        method: http.RequestMethod.POST,
        body: JSON.stringify(dynamicData)
      });

      console.log('ğŸŒ APIå“åº”:', JSON.stringify(response));

      if (response.success) {
        console.log('âœ… åˆ›å»ºåŠ¨æ€æˆåŠŸ:', JSON.stringify(response.data));
        return response.data;
      } else {
        console.log('âŒ åˆ›å»ºåŠ¨æ€å¤±è´¥:', response.message);
        throw new Error(response.message || 'Failed to create dynamic');
      }
    } catch (error) {
      console.error('âŒ ApiService.createDynamic å¼‚å¸¸:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æœªçŸ¥é”™è¯¯: ' + JSON.stringify(error));
      }
    }
  }

  /**
   * è·å–ç”¨æˆ·çš„æ‰€æœ‰åŠ¨æ€
   */
  static async getUserDynamics(userUID: string): Promise<Dynamic[]> {
    const response = await ApiService.request<Dynamic[]>(`${API_BASE_URL}/dynamic/user/${userUID}`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get user dynamics');
    }
  }

  /**
   * è·å–ç”¨æˆ·çš„å…¬å¼€åŠ¨æ€
   */
  static async getUserPublicDynamics(userUID: string): Promise<Dynamic[]> {
    const response = await ApiService.request<Dynamic[]>(`${API_BASE_URL}/dynamic/user/${userUID}/public`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get user public dynamics');
    }
  }

  /**
   * ç‚¹èµåŠ¨æ€
   */
  static async likeDynamic(dynamicId: string): Promise<boolean> {
    const response = await ApiService.request<boolean>(`${API_BASE_URL}/dynamic/${dynamicId}/like`, {
      method: http.RequestMethod.POST
    });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to like dynamic');
    }
  }

  /**
   * å–æ¶ˆç‚¹èµåŠ¨æ€
   */
  static async unlikeDynamic(dynamicId: string): Promise<boolean> {
    const response = await ApiService.request<boolean>(`${API_BASE_URL}/dynamic/${dynamicId}/unlike`, {
      method: http.RequestMethod.POST
    });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to unlike dynamic');
    }
  }

  /**
   * åˆ é™¤åŠ¨æ€
   */
  static async deleteDynamic(dynamicId: string, userUID: string): Promise<boolean> {
    const response = await ApiService.request<boolean>(`${API_BASE_URL}/dynamic/${dynamicId}/delete/${userUID}`, {
      method: http.RequestMethod.DELETE
    });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to delete dynamic');
    }
  }

  /**
   * è·å–æ‰€æœ‰å…¬å¼€åŠ¨æ€ï¼ˆåˆ†é¡µï¼‰
   */
  static async getAllPublicDynamics(page: number = 1, size: number = 10): Promise<Dynamic[]> {
    const response = await ApiService.request<Dynamic[]>(`${API_BASE_URL}/dynamic/public?page=${page}&size=${size}`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get public dynamics');
    }
  }

  /**
   * AIç”Ÿæˆä¸“æ æ–‡ç« 
   */
  static async generateAIArticle(type: 'deep' | 'tech' | 'industry', prompt: string): Promise<string> {
    let url = '';
    if (type === 'deep') url = `${API_BASE_URL}/ai/article/deep-analysis?prompt=${encodeURIComponent(prompt)}`;
    if (type === 'tech') url = `${API_BASE_URL}/ai/article/tech-enjoy?prompt=${encodeURIComponent(prompt)}`;
    if (type === 'industry') url =
      `${API_BASE_URL}/ai/article/industry-observation?prompt=${encodeURIComponent(prompt)}`;

    // å•ç‹¬è®¾ç½®5åˆ†é’Ÿè¶…æ—¶ï¼Œæ–¹å¼åŒgenerateFigure
    const httpRequest = http.createHttp();
    const requestOptions: http.HttpRequestOptions = {
      method: http.RequestMethod.GET,
      header: {
        'Content-Type': 'application/json'
      },
      readTimeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
      connectTimeout: 30000 // 30ç§’è¿æ¥è¶…æ—¶
    };
    const response = await httpRequest.request(url, requestOptions);
    httpRequest.destroy();
    if (response.responseCode !== 200) {
      throw new Error(`HTTP error! status: ${response.responseCode}`);
    }
    let result: ApiResponse<AIArticleResponse>;
    try {
      result = JSON.parse(response.result.toString());
      console.log('ğŸŒ JSONè§£ææˆåŠŸ:', result);
    } catch (e) {
      console.error('ğŸŒ APIè¿”å›å†…å®¹ä¸æ˜¯æ ‡å‡†JSONï¼ŒåŸå§‹å†…å®¹å¦‚ä¸‹:');
      console.error(response.result.toString());
      throw new Error('åç«¯è¿”å›å†…å®¹ä¸æ˜¯æ ‡å‡†JSONï¼Œæ— æ³•è§£æ');
    }
    if (!result.success) {
      throw new Error(result.message || 'AIç”Ÿæˆå¤±è´¥');
    }
    return result.data.content;
  }

  /**
   * è·å–"åŠ¨æ¼«"ã€"å¯çˆ±"ã€"ç§‘å¹»"ã€"å†™å®"å››ç§ç±»å‹ï¼Œæ¯ç§ç±»å‹9ä¸ªAIè§’è‰²
   * åç«¯è¿”å› ApiResponse<Record<string, AiRole[]>>ï¼Œå‰ç«¯ç›´æ¥å– data å­—æ®µã€‚
   */
  static async getFeatured4Types(): Promise<Record<string, AiRole[]>> {
    const response = await ApiService.request<Record<string, AiRole[]>>(`${API_BASE_URL}/ai/role/featured4types`);
    if (response.success !== false && response.data) {
      return response.data;
    } else if (response.data) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get featured roles');
    }
  }

  /**
   * è·å–éŸ³ä¹æ’­æ”¾URL
   */
  static async getMusicPlayUrl(musicId: string): Promise<string> {
    const response = await ApiService.request<string>(`${API_BASE_URL}/music/${musicId}/play-url`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'è·å–éŸ³ä¹æ’­æ”¾é“¾æ¥å¤±è´¥');
    }
  }

  /**
   * è·å–éŸ³ä¹ä¿¡æ¯
   */
  static async getMusicInfo(musicId: string): Promise<Record<string, string | number | boolean>> {
    const response =
      await ApiService.request<Record<string, string | number | boolean>>(`${API_BASE_URL}/music/${musicId}/info`);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'è·å–éŸ³ä¹ä¿¡æ¯å¤±è´¥');
    }
  }

  /**
   * è·å–éŸ³ä¹è¯¦æƒ…
   */
  static async getMusicDetail(musicId: string): Promise<MusicDetailVO> {
    const url = `${API_BASE_URL}/music/${musicId}/detail`;
    try {
      const response = await ApiService.request<MusicDetailVO>(url);
      console.log('è·å–æ­Œæ›²è¯¦æƒ…è¿”å›ï¼š', response);
      if (!response.success) {
        throw new Error(response.message || 'è·å–æ­Œæ›²è¯¦æƒ…å¤±è´¥');
      }
      return response.data;
    } catch (e) {
      console.log('è¿›å…¥catchå—ï¼Œid=', musicId);
      console.error('è·å–æ­Œæ›²è¯¦æƒ…å¤±è´¥ï¼Œid=', musicId, e);
      throw new Error(e instanceof Error ? e.message : 'æœªçŸ¥é”™è¯¯');
    }
  }

  /**
   * æµ‹è¯•ç½‘ç»œè¿æ¥
   */
  static async testConnection(): Promise<boolean> {
    try {
      console.log('ğŸ” æµ‹è¯•ç½‘ç»œè¿æ¥...');
      console.log('ğŸ” ç›®æ ‡URL:', `${API_BASE_URL}/user/test`);

      const response = await ApiService.request<string>(`${API_BASE_URL}/user/test`);
      console.log('âœ… ç½‘ç»œè¿æ¥æµ‹è¯•æˆåŠŸ:', response);
      return true;
    } catch (error) {
      console.error('âŒ ç½‘ç»œè¿æ¥æµ‹è¯•å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * æœç´¢ç”¨æˆ·
   */
  static async searchUser(userUID: string): Promise<SearchUserResult | null> {
    try {
      console.log('ğŸ” ApiService.searchUser å¼€å§‹æœç´¢:', userUID);
      console.log('ğŸ” API_BASE_URL:', API_BASE_URL);
      const url = `${API_BASE_URL}/user/search/${userUID}`;
      console.log('ğŸ” è¯·æ±‚URL:', url);
      console.log('ğŸ” å¼€å§‹è°ƒç”¨ request æ–¹æ³•...');

      const response = await ApiService.request<SearchUserResult>(url);
      console.log('ğŸ” APIå“åº”:', response);
      console.log('ğŸ” å“åº”ç±»å‹:', typeof response);
      console.log('ğŸ” å“åº”success:', response.success);
      console.log('ğŸ” å“åº”data:', response.data);
      console.log('ğŸ” å“åº”dataç±»å‹:', typeof response.data);

      if (response.success) {
        console.log('âœ… æœç´¢æˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        console.log('âœ… æ•°æ®å­—æ®µæ£€æŸ¥:');
        console.log('  - userUID:', response.data?.userUID);
        console.log('  - userName:', response.data?.userName);
        console.log('  - userAvatar:', response.data?.userAvatar);
        console.log('  - level:', response.data?.level, 'ç±»å‹:', typeof response.data?.level);
        console.log('  - gender:', response.data?.gender);
        console.log('  - signature:', response.data?.signature);
        return response.data;
      } else {
        console.log('âŒ æœç´¢å¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        return null; // ç”¨æˆ·ä¸å­˜åœ¨
      }
    } catch (error) {
      console.error('âŒ æœç´¢ç”¨æˆ·å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));
      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
      }
      return null; // æœç´¢å¤±è´¥æ—¶è¿”å›null
    }
  }

  /**
   * åˆ›å»ºAIè§’è‰²
   */
  static async createAiRole(aiRoleData: CreateAiRoleRequest): Promise<AiRole> {
    try {
      console.log('ğŸ¤– ApiService.createAiRole å¼€å§‹åˆ›å»ºAIè§’è‰²:', aiRoleData);
      console.log('ğŸ¤– API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/role/create`;
      console.log('ğŸ¤– è¯·æ±‚URL:', url);

      const requestBody: CreateAiRoleRequest = {
        userId: aiRoleData.userId,
        roleName: aiRoleData.roleName,
        roleDescription: aiRoleData.roleDescription,
        roleType: aiRoleData.roleType,
        roleAuthor: aiRoleData.roleAuthor,
        avatarUrl: aiRoleData.avatarUrl,
        isTemplate: aiRoleData.isTemplate || false
      };

      console.log('ğŸ¤– è¯·æ±‚ä½“:', JSON.stringify(requestBody));

      const response = await ApiService.request<AiRole>(url, {
        method: http.RequestMethod.POST,
        body: JSON.stringify(requestBody)
      });

      console.log('ğŸ¤– APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… AIè§’è‰²åˆ›å»ºæˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ AIè§’è‰²åˆ›å»ºå¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to create AI role');
      }
    } catch (error) {
      console.error('âŒ åˆ›å»ºAIè§’è‰²å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('åˆ›å»ºAIè§’è‰²å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ ¹æ®æè¿°è¯ç”ŸæˆAIè§’è‰²åç§°
   */
  static async generateRoleName(description: string): Promise<string> {
    try {
      console.log('ğŸ¯ ApiService.generateRoleName å¼€å§‹ç”Ÿæˆè§’è‰²åç§°');
      console.log('ğŸ¯ æè¿°è¯:', description);
      console.log('ğŸ¯ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/role/generate-name`;
      console.log('ğŸ¯ è¯·æ±‚URL:', url);

      const requestBody: GenerateRoleNameRequest = {
        description: description
      };

      console.log('ğŸ¯ è¯·æ±‚ä½“:', JSON.stringify(requestBody));

      const response = await ApiService.request<string>(url, {
        method: http.RequestMethod.POST,
        body: JSON.stringify(requestBody)
      });

      console.log('ğŸ¯ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… è§’è‰²åç§°ç”ŸæˆæˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ è§’è‰²åç§°ç”Ÿæˆå¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to generate role name');
      }
    } catch (error) {
      console.error('âŒ ç”Ÿæˆè§’è‰²åç§°å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('ç”Ÿæˆè§’è‰²åç§°å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * åˆ›å»ºå¯¹è¯
   */
  static async createConversation(conversationData: CreateConversationRequest): Promise<Conversation> {
    try {
      console.log('ğŸ’¬ ApiService.createConversation å¼€å§‹åˆ›å»ºå¯¹è¯:', conversationData);
      console.log('ğŸ’¬ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/history/conversation/create`;
      console.log('ğŸ’¬ è¯·æ±‚URL:', url);

      const requestBody: CreateConversationRequest = {
        userId: conversationData.userId,
        aiRoleId: conversationData.aiRoleId,
        title: conversationData.title,
        moodTag: conversationData.moodTag
      };

      console.log('ğŸ’¬ è¯·æ±‚ä½“:', JSON.stringify(requestBody));

      const response = await ApiService.request<Conversation>(url, {
        method: http.RequestMethod.POST,
        body: JSON.stringify(requestBody)
      });

      console.log('ğŸ’¬ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… å¯¹è¯åˆ›å»ºæˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ å¯¹è¯åˆ›å»ºå¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to create conversation');
      }
    } catch (error) {
      console.error('âŒ åˆ›å»ºå¯¹è¯å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('åˆ›å»ºå¯¹è¯å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ ¹æ®userIdæŸ¥æ‰¾å…¨éƒ¨å¯¹è¯
   */
  static async getConversationsByUserId(userId: number): Promise<Conversation[]> {
    const url = `${API_BASE_URL}/ai/history/conversation/list?userId=${userId}`;
    const response = await ApiService.request<Conversation[]>(url);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get conversations');
    }
  }

  /**
   * åˆ†æç”¨æˆ·æœ€è¿‘åæ¡å¯¹è¯ä¸­AIè§’è‰²ç±»å‹çš„åå¥½
   */
  static async analyzeUserRolePreference(userId: number, limit: number = 10): Promise<UserRolePreferenceAnalysis> {
    try {
      console.log('ğŸ“Š ApiService.analyzeUserRolePreference å¼€å§‹åˆ†æç”¨æˆ·è§’è‰²åå¥½');
      console.log('ğŸ“Š ç”¨æˆ·ID:', userId);
      console.log('ğŸ“Š åˆ†ææ•°é‡:', limit);

      // 1. è·å–ç”¨æˆ·çš„æ‰€æœ‰å¯¹è¯
      const allConversations = await ApiService.getConversationsByUserId(userId);
      
      if (allConversations.length === 0) {
        console.log('ğŸ“Š ç”¨æˆ·æ²¡æœ‰å¯¹è¯è®°å½•');
        return {
          totalConversations: 0,
          roleTypeCounts: [],
          mostPreferredRoleType: 'æ— æ•°æ®',
          mostPreferredCount: 0,
          analysis: 'ç”¨æˆ·æš‚æ— å¯¹è¯è®°å½•ï¼Œæ— æ³•åˆ†æè§’è‰²åå¥½'
        };
      }

      // 2. æŒ‰æœ€åæ´»è·ƒæ—¶é—´æ’åºï¼Œå–æœ€è¿‘limitæ¡å¯¹è¯
      const recentConversations = allConversations
        .sort((a, b) => new Date(b.lastActive).getTime() - new Date(a.lastActive).getTime())
        .slice(0, limit);

      console.log('ğŸ“Š æœ€è¿‘å¯¹è¯æ•°é‡:', recentConversations.length);

      // 3. è·å–è¿™äº›å¯¹è¯å¯¹åº”çš„AIè§’è‰²ä¿¡æ¯
      const aiRoleIds = Array.from(new Set(recentConversations.map(c => c.aiRoleId)));
      const aiRoleMap: Record<number, AiRole> = {};
      
      for (const id of aiRoleIds) {
        try {
          aiRoleMap[id] = await ApiService.getAiRoleById(id);
        } catch (e) {
          console.error('ğŸ“Š è·å–AIè§’è‰²ä¿¡æ¯å¤±è´¥ï¼Œè§’è‰²ID:', id, e);
          // å¤±è´¥åˆ™è·³è¿‡ï¼Œä½¿ç”¨é»˜è®¤è§’è‰²ç±»å‹
          aiRoleMap[id] = {
            id: id,
            userId: null,
            roleName: 'æœªçŸ¥è§’è‰²',
            roleDescription: '',
            roleType: 'æœªçŸ¥ç±»å‹',
            roleAuthor: '',
            viewCount: 0,
            avatarUrl: '',
            isTemplate: false,
            createdAt: ''
          };
        }
      }

      // 4. ç»Ÿè®¡è§’è‰²ç±»å‹
      const roleTypeCount: Record<string, number> = {};
      let totalValidConversations = 0;

      for (const conversation of recentConversations) {
        const aiRole = aiRoleMap[conversation.aiRoleId];
        if (aiRole && aiRole.roleType) {
          const roleType = aiRole.roleType;
          roleTypeCount[roleType] = (roleTypeCount[roleType] || 0) + 1;
          totalValidConversations++;
        }
      }

      // 5. è½¬æ¢ä¸ºç»Ÿè®¡ç»“æœæ ¼å¼
      const roleTypeCounts: RoleTypeStatistics[] = [];
      for (const entry of Object.entries(roleTypeCount)) {
        const roleType = entry[0];
        const count = entry[1];
        const percentage = Math.round((count / totalValidConversations) * 100);
        roleTypeCounts.push({
          roleType: roleType,
          count: count,
          percentage: percentage
        });
      }
      // æŒ‰æ•°é‡é™åºæ’åˆ—
      roleTypeCounts.sort((a, b) => b.count - a.count);

      // 6. æ‰¾å‡ºæœ€å—æ¬¢è¿çš„è§’è‰²ç±»å‹
      const mostPreferred = roleTypeCounts.length > 0 ? roleTypeCounts[0] : null;

      // 7. ç”Ÿæˆåˆ†ææ–‡æœ¬
      let analysis = '';
      if (roleTypeCounts.length === 0) {
        analysis = 'ç”¨æˆ·æš‚æ— æœ‰æ•ˆçš„å¯¹è¯è®°å½•';
      } else if (roleTypeCounts.length === 1 && mostPreferred !== null) {
        analysis = `ç”¨æˆ·ä¸“æ³¨äºä¸${mostPreferred.roleType}ç±»å‹çš„AIè§’è‰²äº¤æµ`;
      } else if (mostPreferred !== null) {
        const topType = mostPreferred.roleType;
        const topPercentage = mostPreferred.percentage;
        analysis = `ç”¨æˆ·æœ€å–œæ¬¢ä¸${topType}ç±»å‹çš„AIè§’è‰²äº¤æµï¼Œå æ¯”${topPercentage}%ã€‚`;
        
        if (roleTypeCounts.length > 1) {
          const secondType = roleTypeCounts[1].roleType;
          const secondPercentage = roleTypeCounts[1].percentage;
          analysis += `å…¶æ¬¡æ˜¯${secondType}ç±»å‹ï¼Œå æ¯”${secondPercentage}%ã€‚`;
        }
      }

      const result: UserRolePreferenceAnalysis = {
        totalConversations: totalValidConversations,
        roleTypeCounts,
        mostPreferredRoleType: mostPreferred ? mostPreferred.roleType : 'æ— æ•°æ®',
        mostPreferredCount: mostPreferred ? mostPreferred.count : 0,
        analysis
      };

      console.log('ğŸ“Š è§’è‰²åå¥½åˆ†æå®Œæˆ:', result);
      return result;

    } catch (error) {
      console.error('âŒ åˆ†æç”¨æˆ·è§’è‰²åå¥½å¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('åˆ†æç”¨æˆ·è§’è‰²åå¥½å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ ¹æ®aiRoleIdè·å–AIè§’è‰²è¯¦æƒ…
   */
  static async getAiRoleById(aiRoleId: number): Promise<AiRole> {
    const url = `${API_BASE_URL}/ai/role/${aiRoleId}`;
    const response = await ApiService.request<AiRole>(url);
    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'Failed to get ai role');
    }
  }

  /**
   * ä¿å­˜æ¶ˆæ¯åˆ°æ•°æ®åº“
   */
  static async saveMessage(messageData: CreateMessageRequest): Promise<Message> {
    try {
      console.log('ğŸ’¬ ApiService.saveMessage å¼€å§‹ä¿å­˜æ¶ˆæ¯:', messageData);
      console.log('ğŸ’¬ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/message/save`;
      console.log('ğŸ’¬ è¯·æ±‚URL:', url);

      const requestBody: CreateMessageRequest = {
        conversationId: messageData.conversationId,
        senderType: messageData.senderType,
        content: messageData.content,
        audioUrl: messageData.audioUrl,
        sentimentScore: messageData.sentimentScore,
        topicTag: messageData.topicTag
      };

      console.log('ğŸ’¬ è¯·æ±‚ä½“:', JSON.stringify(requestBody));

      const response = await ApiService.request<Message>(url, {
        method: http.RequestMethod.POST,
        body: JSON.stringify(requestBody)
      });

      console.log('ğŸ’¬ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… æ¶ˆæ¯ä¿å­˜æˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ æ¶ˆæ¯ä¿å­˜å¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to save message');
      }
    } catch (error) {
      console.error('âŒ ä¿å­˜æ¶ˆæ¯å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('ä¿å­˜æ¶ˆæ¯å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ ¹æ®ä¼šè¯IDè·å–æ¶ˆæ¯åˆ—è¡¨
   */
  static async getMessagesByConversationId(conversationId: number): Promise<Message[]> {
    try {
      console.log('ğŸ’¬ ApiService.getMessagesByConversationId å¼€å§‹è·å–æ¶ˆæ¯åˆ—è¡¨');
      console.log('ğŸ’¬ ä¼šè¯ID:', conversationId);
      console.log('ğŸ’¬ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/message/list?conversationId=${conversationId}`;
      console.log('ğŸ’¬ è¯·æ±‚URL:', url);

      const response = await ApiService.request<Message[]>(url);

      console.log('ğŸ’¬ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… è·å–æ¶ˆæ¯åˆ—è¡¨æˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ è·å–æ¶ˆæ¯åˆ—è¡¨å¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to get messages');
      }
    } catch (error) {
      console.error('âŒ è·å–æ¶ˆæ¯åˆ—è¡¨å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('è·å–æ¶ˆæ¯åˆ—è¡¨å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ ¹æ®ç”¨æˆ·IDå’ŒAIè§’è‰²IDæŸ¥æ‰¾å¯¹è¯
   */
  static async findConversationByUserAndRole(userId: number, aiRoleId: number): Promise<Conversation | null> {
    try {
      console.log('ğŸ’¬ ApiService.findConversationByUserAndRole å¼€å§‹æŸ¥æ‰¾å¯¹è¯');
      console.log('ğŸ’¬ ç”¨æˆ·ID:', userId);
      console.log('ğŸ’¬ AIè§’è‰²ID:', aiRoleId);
      console.log('ğŸ’¬ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/history/conversation/find?userId=${userId}&aiRoleId=${aiRoleId}`;
      console.log('ğŸ’¬ è¯·æ±‚URL:', url);

      const response = await ApiService.request<Conversation>(url);

      console.log('ğŸ’¬ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… æŸ¥æ‰¾å¯¹è¯æˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ æŸ¥æ‰¾å¯¹è¯å¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        // å¦‚æœæ‰¾ä¸åˆ°å¯¹è¯ï¼Œè¿”å›nullè€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
        if (response.message && (response.message.includes('not found') || response.message.includes('æœªæ‰¾åˆ°'))) {
          console.log('ğŸ“ å¯¹è¯ä¸å­˜åœ¨ï¼Œè¿”å›null');
          return null;
        }
        throw new Error(response.message || 'Failed to find conversation');
      }
    } catch (error) {
      console.error('âŒ æŸ¥æ‰¾å¯¹è¯å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('æŸ¥æ‰¾å¯¹è¯å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ ¹æ®ç”¨æˆ·IDå’ŒAIè§’è‰²IDæŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹è¯
   */
  static async findOrCreateConversation(userId: number, aiRoleId: number, title?: string): Promise<Conversation> {
    try {
      console.log('ğŸ’¬ ApiService.findOrCreateConversation å¼€å§‹æŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹è¯');
      console.log('ğŸ’¬ ç”¨æˆ·ID:', userId);
      console.log('ğŸ’¬ AIè§’è‰²ID:', aiRoleId);
      console.log('ğŸ’¬ æ ‡é¢˜:', title);

      // é¦–å…ˆå°è¯•æŸ¥æ‰¾ç°æœ‰å¯¹è¯
      const existingConversation = await ApiService.findConversationByUserAndRole(userId, aiRoleId);

      if (existingConversation) {
        console.log('âœ… æ‰¾åˆ°ç°æœ‰å¯¹è¯:', existingConversation);
        return existingConversation;
      }

      console.log('ğŸ“ æœªæ‰¾åˆ°ç°æœ‰å¯¹è¯ï¼Œå¼€å§‹åˆ›å»ºæ–°å¯¹è¯...');

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ›å»ºæ–°å¯¹è¯
      const conversationData: CreateConversationRequest = {
        userId: userId,
        aiRoleId: aiRoleId,
        title: title || `ä¸AIè§’è‰²çš„å¯¹è¯`,
        moodTag: 'normal'
      };

      const newConversation = await ApiService.createConversation(conversationData);
      console.log('âœ… åˆ›å»ºæ–°å¯¹è¯æˆåŠŸ:', newConversation);
      return newConversation;

    } catch (error) {
      console.error('âŒ æŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹è¯å¤±è´¥:', error);
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error('æŸ¥æ‰¾æˆ–åˆ›å»ºå¯¹è¯å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * åˆ†æå¯¹è¯æƒ…ç»ªå¹¶æ›´æ–°æƒ…ç»ªæ ‡ç­¾
   */
  static async analyzeConversationEmotion(conversationId: number): Promise<string> {
    try {
      console.log('ğŸ’¬ ApiService.analyzeConversationEmotion å¼€å§‹åˆ†æå¯¹è¯æƒ…ç»ª');
      console.log('ğŸ’¬ ä¼šè¯ID:', conversationId);
      console.log('ğŸ’¬ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/analyze-emotion?conversationId=${conversationId}`;
      console.log('ğŸ’¬ è¯·æ±‚URL:', url);

      const response = await ApiService.request<string>(url, {
        method: http.RequestMethod.POST
      });

      console.log('ğŸ’¬ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… æƒ…ç»ªåˆ†ææˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ æƒ…ç»ªåˆ†æå¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to analyze emotion');
      }
    } catch (error) {
      console.error('âŒ æƒ…ç»ªåˆ†æå¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('æƒ…ç»ªåˆ†æå¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * ç”Ÿæˆå›å¤å»ºè®®
   */
  static async generateReplySuggestions(conversationId: number): Promise<string[]> {
    try {
      console.log('ğŸ’¬ ApiService.generateReplySuggestions å¼€å§‹ç”Ÿæˆå›å¤å»ºè®®');
      console.log('ğŸ’¬ ä¼šè¯ID:', conversationId);
      console.log('ğŸ’¬ API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/generate-replies?conversationId=${conversationId}`;
      console.log('ğŸ’¬ è¯·æ±‚URL:', url);

      const response = await ApiService.request<string[]>(url, {
        method: http.RequestMethod.POST
      });

      console.log('ğŸ’¬ APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… å›å¤å»ºè®®ç”ŸæˆæˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ å›å¤å»ºè®®ç”Ÿæˆå¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to generate reply suggestions');
      }
    } catch (error) {
      console.error('âŒ å›å¤å»ºè®®ç”Ÿæˆå¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('å›å¤å»ºè®®ç”Ÿæˆå¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }


  // ==================== è¯„è®ºç³»ç»Ÿæ¥å£ ====================

  /**
   * è·å–AIè§’è‰²çš„è¯„è®ºåˆ—è¡¨
   */
  static async getCommentsByAiRoleId(aiRoleId: number, page: number = 1,
    size: number = 10): Promise<CommentListResponse> {
    const response =
      await ApiService.request<CommentListResponse>(`${API_BASE_URL}/comments/ai-role/${aiRoleId}?page=${page}&size=${size}`);

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'è·å–è¯„è®ºåˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * è·å–è¯„è®ºçš„å›å¤åˆ—è¡¨
   */
  static async getRepliesByRootCommentId(rootCommentId: number, page: number = 1,
    size: number = 10): Promise<ReplyListResponse> {
    const response =
      await ApiService.request<ReplyListResponse>(`${API_BASE_URL}/comments/${rootCommentId}/replies?page=${page}&size=${size}`);

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'è·å–å›å¤åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * å‘å¸ƒè¯„è®º
   */
  static async publishComment(aiRoleId: number, userId: number, content: string): Promise<PublishCommentResponse> {
    const response = await ApiService.request<PublishCommentResponse>(`${API_BASE_URL}/comments/publish`, {
      method: http.RequestMethod.POST,
      body: JSON.stringify({
        aiRoleId: aiRoleId,
        userId: userId,
        content: content
      })
    });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'å‘å¸ƒè¯„è®ºå¤±è´¥');
    }
  }

  /**
   * å›å¤è¯„è®º
   */
  static async replyComment(aiRoleId: number, userId: number, content: string, rootCommentId: number,
    toCommentId?: number): Promise<ReplyCommentResponse> {
    const requestBody: ReplyCommentRequestBody = {
      aiRoleId: aiRoleId,
      userId: userId,
      content: content,
      rootCommentId: rootCommentId
    };

    if (toCommentId) {
      requestBody.toCommentId = toCommentId;
    }

    const response = await ApiService.request<ReplyCommentResponse>(`${API_BASE_URL}/comments/reply`, {
      method: http.RequestMethod.POST,
      body: JSON.stringify(requestBody)
    });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'å‘å¸ƒå›å¤å¤±è´¥');
    }
  }

  /**
   * ç‚¹èµè¯„è®º
   */
  static async likeComment(commentId: number, userId: number): Promise<LikeOperationResponse> {
    const response =
      await ApiService.request<LikeOperationResponse>(`${API_BASE_URL}/comments/${commentId}/like?userId=${userId}`, {
        method: http.RequestMethod.POST
      });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'ç‚¹èµå¤±è´¥');
    }
  }

  /**
   * å–æ¶ˆç‚¹èµè¯„è®º
   */
  static async unlikeComment(commentId: number, userId: number): Promise<LikeOperationResponse> {
    const response =
      await ApiService.request<LikeOperationResponse>(`${API_BASE_URL}/comments/${commentId}/like?userId=${userId}`, {
        method: http.RequestMethod.DELETE
      });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'å–æ¶ˆç‚¹èµå¤±è´¥');
    }
  }

  /**
   * åˆ é™¤è¯„è®º
   */
  static async deleteComment(commentId: number, userId: number): Promise<DeleteCommentResponse> {
    const response =
      await ApiService.request<DeleteCommentResponse>(`${API_BASE_URL}/comments/${commentId}?userId=${userId}`, {
        method: http.RequestMethod.DELETE
      });

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'åˆ é™¤è¯„è®ºå¤±è´¥');
    }
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç‚¹èµè¯„è®º
   */
  static async checkUserLikedComment(commentId: number, userId: number): Promise<CheckLikeStatusResponse> {
    const response =
      await ApiService.request<CheckLikeStatusResponse>(`${API_BASE_URL}/comments/${commentId}/liked?userId=${userId}`);

    if (response.success) {
      return response.data;
    } else {
      throw new Error(response.message || 'æ£€æŸ¥ç‚¹èµçŠ¶æ€å¤±è´¥');
    }
  }

  /**
   * æ ¹æ®ç”¨æˆ·IDè·å–ç”¨æˆ·åˆ›å»ºçš„AIè§’è‰²åˆ—è¡¨
   */
  static async getUserAiRoles(userId: number): Promise<AiRole[]> {
    try {
      console.log('ğŸ¤– ApiService.getUserAiRoles å¼€å§‹è·å–ç”¨æˆ·AIè§’è‰²åˆ—è¡¨');
      console.log('ğŸ¤– ç”¨æˆ·ID:', userId);
      console.log('ğŸ¤– API_BASE_URL:', API_BASE_URL);

      const url = `${API_BASE_URL}/ai/role/user/${userId}`;
      console.log('ğŸ¤– è¯·æ±‚URL:', url);

      const response = await ApiService.request<AiRole[]>(url);

      console.log('ğŸ¤– APIå“åº”:', response);

      if (response.success) {
        console.log('âœ… è·å–ç”¨æˆ·AIè§’è‰²åˆ—è¡¨æˆåŠŸï¼Œè¿”å›æ•°æ®:', response.data);
        return response.data;
      } else {
        console.log('âŒ è·å–ç”¨æˆ·AIè§’è‰²åˆ—è¡¨å¤±è´¥ï¼ŒAPIè¿”å›é”™è¯¯:', response.message);
        throw new Error(response.message || 'Failed to get user AI roles');
      }
    } catch (error) {
      console.error('âŒ è·å–ç”¨æˆ·AIè§’è‰²åˆ—è¡¨å¤±è´¥:', error);
      console.error('âŒ é”™è¯¯ç±»å‹:', typeof error);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));

      if (error instanceof Error) {
        console.error('âŒ é”™è¯¯æ¶ˆæ¯:', error.message);
        console.error('âŒ é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
      } else {
        throw new Error('è·å–ç”¨æˆ·AIè§’è‰²åˆ—è¡¨å¤±è´¥: æœªçŸ¥é”™è¯¯');
      }
    }
  }

  /**
   * æ›´å…·UIDè·å–ç”¨æˆ·ID
   */
  static async getUserIdByUID(uid: string): Promise<number> {
    const response = await ApiService.request<number>(`${API_BASE_URL}/user/findIDByUID?uid=${encodeURIComponent(uid)}`);
    if (response && response.success) {
      return response.data;
    } else {
      throw new Error(response?.message || 'è·å–ç”¨æˆ·IDå¤±è´¥');
    }
  }
}

