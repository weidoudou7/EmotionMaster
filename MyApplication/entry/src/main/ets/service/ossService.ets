// OSSæœåŠ¡ç±» - ç”¨äºå¤„ç†é˜¿é‡Œäº‘OSSå¯¹è±¡å­˜å‚¨
import http from '@ohos.net.http';
import fs from '@ohos.file.fs';
import { Config } from '../common/config';
import { AvatarUploadRequest, AvatarUploadResponse } from '../common/types';

// å®šä¹‰æ¥å£
interface OSSConfig {
  endpoint: string;
  bucketName: string;
  accessKeyId: string;
  accessKeySecret: string;
  region: string;
}

interface OSSHeaders {
  'Content-Type': string;
  'Content-Length': string;
  'Authorization': string;
}

interface OSSRequestData {
  userId: string;
  imageData: string;
  fileName: string;
}

interface OSSResponse {
  ossUrl: string;
}

interface OSSHttpRequestOptions {
  method: http.RequestMethod;
  header: OSSHeaders;
  extraData: string;
  readTimeout: number;
  connectTimeout: number;
}

interface OSSBackendHeader {
  'Content-Type': string;
}

interface OSSBackendRequestOptions {
  method: http.RequestMethod;
  header: OSSBackendHeader;
  extraData: string;
  readTimeout: number;
  connectTimeout: number;
}

interface BackendOSSResponseData {
  ossUrl: string;
}

interface BackendOSSResponse {
  success: boolean;
  message: string;
  data?: BackendOSSResponseData;
}

export class OSSService {
  private static instance: OSSService;
  private ossConfig: OSSConfig = {
    endpoint: 'https://oss-cn-hangzhou.aliyuncs.com', // æ›¿æ¢ä¸ºä½ çš„OSS endpoint
    bucketName: 'your-bucket-name', // æ›¿æ¢ä¸ºä½ çš„bucketåç§°
    accessKeyId: 'your-access-key-id', // æ›¿æ¢ä¸ºä½ çš„AccessKey ID
    accessKeySecret: 'your-access-key-secret', // æ›¿æ¢ä¸ºä½ çš„AccessKey Secret
    region: 'cn-hangzhou' // æ›¿æ¢ä¸ºä½ çš„region
  };

  private constructor() {}

  public static getInstance(): OSSService {
    if (!OSSService.instance) {
      OSSService.instance = new OSSService();
    }
    return OSSService.instance;
  }

  /**
   * ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶åˆ°OSS
   * @param filePath æœ¬åœ°æ–‡ä»¶è·¯å¾„
   * @param fileName æ–‡ä»¶åï¼ˆå¯é€‰ï¼Œå¦‚æœä¸æä¾›åˆ™ä½¿ç”¨æ—¶é—´æˆ³ç”Ÿæˆï¼‰
   * @returns Promise<string> è¿”å›OSSè®¿é—®URL
   */
  async uploadImageToOSS(filePath: string, fileName?: string): Promise<string> {
    try {
      console.log('â˜ï¸ [OSS] å¼€å§‹ä¸Šä¼ å›¾ç‰‡åˆ°OSS');
      console.log('â˜ï¸ [OSS] æ–‡ä»¶è·¯å¾„:', filePath);
      console.log('â˜ï¸ [OSS] æ–‡ä»¶å:', fileName);

      // è¯»å–æ–‡ä»¶å†…å®¹
      const fileContent = await this.readFileAsBase64(filePath);
      console.log('â˜ï¸ [OSS] æ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¤§å°:', fileContent.length, 'å­—ç¬¦');

      // ç”Ÿæˆæ–‡ä»¶å
      const finalFileName = fileName || this.generateFileName(filePath);
      console.log('â˜ï¸ [OSS] æœ€ç»ˆæ–‡ä»¶å:', finalFileName);

      // æ„å»ºOSSä¸Šä¼ URL
      const uploadUrl = `${this.ossConfig.endpoint}/${this.ossConfig.bucketName}/${finalFileName}`;
      console.log('â˜ï¸ [OSS] ä¸Šä¼ URL:', uploadUrl);

      // åˆ›å»ºHTTPè¯·æ±‚
      const httpRequest = http.createHttp();
      
      // æ„å»ºè¯·æ±‚å¤´
      const headers: OSSHeaders = {
        'Content-Type': this.getContentType(filePath),
        'Content-Length': fileContent.length.toString(),
        'Authorization': this.generateOSSAuthorization('PUT', finalFileName, this.getContentType(filePath))
      };

      console.log('â˜ï¸ [OSS] è¯·æ±‚å¤´:', headers);

      // å‘é€PUTè¯·æ±‚ä¸Šä¼ æ–‡ä»¶
      const requestOptions: OSSHttpRequestOptions = {
        method: http.RequestMethod.PUT,
        header: headers,
        extraData: fileContent,
        readTimeout: 30000,
        connectTimeout: 30000
      };
      const response = await httpRequest.request(uploadUrl, requestOptions);

      httpRequest.destroy();

      console.log('â˜ï¸ [OSS] ä¸Šä¼ å“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('â˜ï¸ [OSS] ä¸Šä¼ å“åº”å¤´:', response.header);

      if (response.responseCode === 200) {
        // æ„å»ºè®¿é—®URL
        const accessUrl = `https://${this.ossConfig.bucketName}.${this.ossConfig.endpoint.replace('https://', '')}/${finalFileName}`;
        console.log('â˜ï¸ [OSS] ä¸Šä¼ æˆåŠŸï¼Œè®¿é—®URL:', accessUrl);
        return accessUrl;
      } else {
        console.error('â˜ï¸ [OSS] ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç :', response.responseCode);
        console.error('â˜ï¸ [OSS] å“åº”å†…å®¹:', response.result);
        throw new Error(`OSSä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.responseCode}`);
      }
    } catch (error) {
      console.error('â˜ï¸ [OSS] ä¸Šä¼ å›¾ç‰‡åˆ°OSSå¤±è´¥:', error);
      throw new Error(`OSSä¸Šä¼ å¤±è´¥: ${error.message || error}`);
    }
  }

  /**
   * è¯»å–æ–‡ä»¶å¹¶è½¬æ¢ä¸ºbase64
   */
  private async readFileAsBase64(filePath: string): Promise<string> {
    try {
      console.log('ğŸ“ [OSS] å¼€å§‹è¯»å–æ–‡ä»¶:', filePath);
      
      // æ‰“å¼€æ–‡ä»¶
      const file = fs.openSync(filePath, fs.OpenMode.READ_ONLY);
      console.log('ğŸ“ [OSS] æ–‡ä»¶æ‰“å¼€æˆåŠŸ');

      // è·å–æ–‡ä»¶å¤§å°
      const stat = fs.statSync(file.fd);
      console.log('ğŸ“ [OSS] æ–‡ä»¶å¤§å°:', stat.size, 'å­—èŠ‚');

      if (stat.size === 0) {
        fs.closeSync(file);
        throw new Error('æ–‡ä»¶å¤§å°ä¸º0');
      }

      // è¯»å–æ–‡ä»¶å†…å®¹
      const buffer = new ArrayBuffer(stat.size);
      fs.readSync(file.fd, buffer);
      console.log('ğŸ“ [OSS] æ–‡ä»¶è¯»å–æˆåŠŸ');

      // å…³é—­æ–‡ä»¶
      fs.closeSync(file);

      // è½¬æ¢ä¸ºbase64
      const base64 = this.arrayBufferToBase64(buffer);
      console.log('ğŸ“ [OSS] base64è½¬æ¢å®Œæˆï¼Œé•¿åº¦:', base64.length);

      return base64;
    } catch (error) {
      console.error('ğŸ“ [OSS] è¯»å–æ–‡ä»¶å¤±è´¥:', error);
      throw new Error(`è¯»å–æ–‡ä»¶å¤±è´¥: ${error.message || error}`);
    }
  }

  /**
   * ç”Ÿæˆæ–‡ä»¶å
   */
  private generateFileName(originalPath: string): string {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    const extension = originalPath.split('.').pop() || 'jpg';
    return `avatars/${timestamp}_${random}.${extension}`;
  }

  /**
   * è·å–æ–‡ä»¶MIMEç±»å‹
   */
  private getContentType(filePath: string): string {
    const extension = filePath.split('.').pop()?.toLowerCase() || 'jpeg';
    switch (extension) {
      case 'png':
        return 'image/png';
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'gif':
        return 'image/gif';
      case 'webp':
        return 'image/webp';
      default:
        return 'image/jpeg';
    }
  }

  /**
   * ç”ŸæˆOSSæˆæƒå¤´
   */
  private generateOSSAuthorization(method: string, resource: string, contentType: string): string {
    // è¿™é‡Œéœ€è¦å®ç°OSSç­¾åç®—æ³•
    // ä¸ºäº†å®‰å…¨è€ƒè™‘ï¼Œå»ºè®®åœ¨æœåŠ¡ç«¯ç”Ÿæˆç­¾å
    // è¿™é‡Œæä¾›ä¸€ä¸ªç®€åŒ–çš„ç¤ºä¾‹
    const date = new Date().toUTCString();
    const stringToSign = `${method}\n\n${contentType}\n${date}\n/${this.ossConfig.bucketName}/${resource}`;
    
    // æ³¨æ„ï¼šå®é™…é¡¹ç›®ä¸­åº”è¯¥ä½¿ç”¨æœåŠ¡ç«¯ç”Ÿæˆçš„ç­¾å
    // è¿™é‡Œåªæ˜¯ç¤ºä¾‹ï¼Œå®é™…ä½¿ç”¨æ—¶éœ€è¦è°ƒç”¨åç«¯APIè·å–ç­¾å
    return `OSS ${this.ossConfig.accessKeyId}:${this.generateSignature(stringToSign)}`;
  }

  /**
   * ç”Ÿæˆç­¾åï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥ä½¿ç”¨HMAC-SHA1ï¼‰
   */
  private generateSignature(stringToSign: string): string {
    // è¿™é‡Œåº”è¯¥ä½¿ç”¨HMAC-SHA1ç®—æ³•
    // ä¸ºäº†ç®€åŒ–ï¼Œè¿™é‡Œè¿”å›ä¸€ä¸ªå ä½ç¬¦
    // å®é™…é¡¹ç›®ä¸­åº”è¯¥è°ƒç”¨åç«¯APIè·å–ç­¾å
    return 'signature_placeholder';
  }

  /**
   * ArrayBufferè½¬base64
   */
  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const uint8Array = new Uint8Array(buffer);
    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '';

    for (let i = 0; i < uint8Array.length; i += 3) {
      const byte1 = uint8Array[i];
      const byte2 = i + 1 < uint8Array.length ? uint8Array[i + 1] : 0;
      const byte3 = i + 2 < uint8Array.length ? uint8Array[i + 2] : 0;

      const chunk1 = byte1 >> 2;
      const chunk2 = ((byte1 & 3) << 4) | (byte2 >> 4);
      const chunk3 = ((byte2 & 15) << 2) | (byte3 >> 6);
      const chunk4 = byte3 & 63;

      result += base64Chars.charAt(chunk1);
      result += base64Chars.charAt(chunk2);
      result += i + 1 < uint8Array.length ? base64Chars.charAt(chunk3) : '=';
      result += i + 2 < uint8Array.length ? base64Chars.charAt(chunk4) : '=';
    }

    return result;
  }

  /**
   * é€šè¿‡åç«¯APIä¸Šä¼ åˆ°OSSï¼ˆæ¨èæ–¹å¼ï¼‰
   */
  async uploadImageViaBackend(filePath: string, userId: string): Promise<string> {
    try {
      console.log('â˜ï¸ [OSS] é€šè¿‡åç«¯APIä¸Šä¼ å›¾ç‰‡');
      console.log('â˜ï¸ [OSS] æ–‡ä»¶è·¯å¾„:', filePath);
      console.log('â˜ï¸ [OSS] ç”¨æˆ·ID:', userId);

      // è¯»å–æ–‡ä»¶å†…å®¹
      const fileContent = await this.readFileAsBase64(filePath);
      console.log('â˜ï¸ [OSS] æ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¤§å°:', fileContent.length, 'å­—ç¬¦');

      // æ„å»ºè¯·æ±‚æ•°æ® - ä½¿ç”¨Bç›®å½•ä¸­ç¨³å®šè¿è¡Œçš„æ ¼å¼
      const requestData: OSSRequestData = {
        userId: userId,
        imageData: fileContent,
        fileName: this.generateFileName(filePath)
      };

      console.log('â˜ï¸ [OSS] è¯·æ±‚æ•°æ®æ ¼å¼:', JSON.stringify({
        userId: userId,
        imageData: fileContent.substring(0, 100) + '...', // åªæ˜¾ç¤ºå‰100ä¸ªå­—ç¬¦ç”¨äºè°ƒè¯•
        fileName: this.generateFileName(filePath)
      }));

      // è°ƒç”¨åç«¯API - ä½¿ç”¨Bç›®å½•ä¸­çš„ç«¯ç‚¹
      const httpRequest = http.createHttp();
      const backendHeader: OSSBackendHeader = {
        'Content-Type': 'application/json'
      };
      const backendRequestOptions: OSSBackendRequestOptions = {
        method: http.RequestMethod.POST,
        header: backendHeader,
        extraData: JSON.stringify(requestData),
        readTimeout: 30000,
        connectTimeout: 30000
      };
      const response = await httpRequest.request(`${Config.getApiBaseUrl()}/api/oss/upload`, backendRequestOptions);

      httpRequest.destroy();

      console.log('â˜ï¸ [OSS] åç«¯APIå“åº”çŠ¶æ€ç :', response.responseCode);

      if (response.responseCode === 200) {
        const resultString: string = response.result as string;
        const result: BackendOSSResponse = JSON.parse(resultString);
        console.log('â˜ï¸ [OSS] åç«¯å“åº”:', resultString);
        console.log('â˜ï¸ [OSS] è§£æåçš„å“åº”:', result);
        
        // Bç›®å½•ä¸­çš„å“åº”æ ¼å¼ï¼šresult.data.ossUrl
        if (result.success && result.data && result.data.ossUrl) {
          console.log('â˜ï¸ [OSS] ä¸Šä¼ æˆåŠŸï¼ŒOSS URL:', result.data.ossUrl);
          return result.data.ossUrl;
        } else {
          console.error('â˜ï¸ [OSS] åç«¯è¿”å›å¤±è´¥:', result.message);
          throw new Error(`åç«¯è¿”å›å¤±è´¥: ${result.message}`);
        }
      } else {
        console.error('â˜ï¸ [OSS] åç«¯APIä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç :', response.responseCode);
        console.error('â˜ï¸ [OSS] å“åº”å†…å®¹:', response.result);
        throw new Error(`åç«¯APIä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.responseCode}`);
      }
    } catch (error) {
      console.error('â˜ï¸ [OSS] é€šè¿‡åç«¯APIä¸Šä¼ å¤±è´¥:', error);
      throw new Error(`åç«¯APIä¸Šä¼ å¤±è´¥: ${error.message || error}`);
    }
  }
} 